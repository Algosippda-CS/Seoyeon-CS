# 3주차 운영체제

## 운영체제 (Operating system)

사용자가 컴퓨터를 다루기 쉽게 해주는 인터페이스

사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어의 일종.

### 운영체제의 역할

1. **CPU 스케줄링 & 프로세스 관리**
    
    CPU 소유권을 어떤 프로세스에 할당할지, 프로세스 생성과 삭제, 자원 할당 및 반환 관리
    
2. **메모리 관리**
    
    메모리를 어떤 프로세스에 얼만큼 할당할지 관리
    
3. **디스크 파일 관리**
    
    디스크 파일 보관 방식 관리
    
4. **I/O 디바이스 관리**
    
    마우스, 키보드와 컴퓨터 간 데이터 전송을 관리
    

### 펌웨어

운영체제와 유사하지만, 소프트웨어를 추가로 설치할 수 없는 것 

하드웨어의 제어와 구동을 담당

ex) PC 메인보드의 BIOS

## 운영체제의 구조

![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled.png)

### 💡시스템콜

![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%201.png)

- 프로세스나 스레드에서 운영체제로 어떤 요청을 할 때 시스템콜(인터페이스)과 커널을 거쳐 운영체제에 전달됨.
- 운영체제가 커널에 접근하기 위한 인터페이스
- 우리가 일반적으로 사용하는 유저 프로그램은 유저 레벨의 함수들만으로는 다양한 기능을 구현하기 어렵기 때문에 커널의 도움을 받아야 함.

⇒ 커널의 도움을 받기 위해서는 유저모드에서 수행할 수 없고, 커널모드로 전환해야 함.

⇒ 유저 모드와 커널 모드 간 전환을 시스템콜이 수행함. 

### ✅시스템콜은 유저 모드와 커널 모드를 어떻게 구분할까?

- 카메라, 키보드 등의 I/O 디바이스는 운영체제를 통해서만 작동해야 함
- 유저 모드가 아닌 운영체제를 통해 작동해야 악성 접근을 막기 쉬움
    
    ⇒ modebit를 참고한다.
    
- **modebit**
    - 0(커널 모드) 또는 1(유저 모드)의 값을 가지는 플래그 변수
        
        ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%202.png)
        

## 컴퓨터의 요소

![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%203.png)

### CPU

**제어장치, 레지스터, 산술논리연산장치**로 구성됨

운영체제의 커널 ⇒ 프로그램을 메모리에 올려 프로세스로 만든다.

CPU ⇒ 그 프로세스를 처리한다. 

- **제어장치**
    - 프로세스 조작을 지시
    - 입출력장치 간 통신 제어, 명령어 해석해 데이터 처리를 위한 순서 결정
    
- **레지스터**
    - 매우 빠른 임시기억장치 (메모리의 수십~수백 배)
    - CPU 자체에서 데이터를 저장할 수 없기 때문에 레지스터를 거쳐 데이터 전달
    
- **산술논리연산장치**
    - 두 숫자의 산술 연산, 논리 연산을 계산하는 디지털 회로

### 💡CPU의 연산 처리

1. 제어장치가 메모리와 레지스터에 계산할 값을 로드
2. 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령
3. 제어장치가 계산된 값을 레지스터에 다시 저장하고 이를 메모리에도 저장

### 💡인터럽트

- 어떤 신호가 들어왔을 때 CPU가 하던 작업을 중단하고, 먼저 처리할 다른 작업을 처리한 후, 원래 작업으로 복귀하도록 하는 신호
- 인터럽트 간 우선순위에 따라 실행됨

1) 인터럽트 발생

2) 인터럽트 핸들러 함수가 모여 있는 인터럽트 벡터로 이동

3) 인터럽트 핸들러 함수 실행 

- **하드웨어 인터럽트**
    - IO 디바이스에서 발생하는 인터럽트
    
- **소프트웨어 인터럽트**
    - 트랩이라고도 함
    - 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동

### 💡인터럽트가 필요한 이유

운영체제는 동시에 여러 작업을 처리할 수 없지만, 사용자는 한 번에 여러 작업을 처리하길 원한다. 

EX) 인쇄 기능 사용 시

CPU가 프린터에 문서 인쇄 지시 ⇒ 프린터가 작업 수행 ⇒ CPU는 프린터의 작업이 끝날 때까지 기다려야 함 ⇒ 비효율적!!! 

⇒ 인터럽트가 작동하면 CPU는 프린터의 작업이 끝나기 전에 다른 작업을 하고 올 수 있음

### DMA 컨트롤러 (Direct memory access)

- I/O 디바이스가 메모리에 직접 접근 가능하게 하는 하드웨어 장치
- CPU에 너무 많은 인터럽트 요청이 들어오기 때문에
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것 방지

### 메모리

- 데이터, 상태, 명령어 등을 기록하는 장치
- RAM(Random Access Memory)을 메모리로 통칭하기도 함
- CPU는 계산 담당, 메모리는 기억 담당
- 메모리 클수록 멀티태스킹 용이

### 타이머

- 시간이 많이 걸리는 특정 프로그램이 작동할 때, 작동하는 시간에 제한을 거는 역할

### 디바이스 컨트롤러

- IO 디바이스들의 작은 CPU
- **로컬 버퍼** : 각 디바이스에서 데이터를 임시 저장하기 위한 작은 메모리

## 메모리

### 💡메모리 계층

- 메모리를 속도, 용량, 비용 간 절충관계를 고려해 나타낸 구조
    
    ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%204.png)
    
    ### 캐시
    
    - 데이터를 미리 복사해 놓는 임시 저장소
    - 장치 간 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
    - 자주 사용하는 데이터를 기반으로 설정해야 함
        - **시간 지역성**
            - 최근 사용한 데이터에 다시 접근하려는 특성
        - **공간 지역성**
            - 최근 접근한 데이터와 가까운 공간에 접근하는 특성
        
        ### 캐시히트와 캐시미스
        
        - **캐시히트**
            - 캐시에서 원하는 데이터를 찾은 경우
            - CPU 내부 버스를 기반으로 작동하므로 속도가 빠름
            
        - **캐시미스**
            - 원하는 데이터가 캐시에 없어 주메모리에서 해당 데이터를 찾아오는 경우
            - 시스템 버스를 기반으로 작동하므로 속도 느림
        
        - **캐시매핑**
            - 캐시가 히트되기 위해 매핑하는 방법
            - 직접 매핑, 연관 매핑, 집합 연관 매핑
        
        ### 웹 브라우저의 캐시
        
        - **쿠키**
            - 데이터 만료기한이 있는 키-값 저장소
            - 4KB까지 데이터 저장 가능
            
             
            
        - **로컬 스토리지**
            - 데이터 만료기한이 없는 키-값 저장소
            - 데이터 영구 저장 가능
            
        - **세션 스토리지**
            - 만료기한이 없는 키-값 저장소
            - 브라우저 탭/윈도우 닫히면 스토리지 초기화
        
        ### 데이터베이스의 캐싱 계층
        
        - 데이터베이스 시스템 구축 시 성능 향상을 위해, 메인 데이터베이스 위에 레디스 데이터 베이스 계층을 캐싱 계층으로 두기도 함
    
    ### 💡메모리 관리 ⇒ 운영체제의 대표적인 역할
    
    ### 가상 메모리
    
    - 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화해, 사용자들에게는 매우 큰 메모리처럼 보이게 만드는 것.
    - 프로세스가 실행되려면 메모리에 올라와 있어야 한다. 하지만 메모리는 한정되어 있다…
    - 프로세스 실행 시, 실행에 필요한 일부분만 메모리에 올라가고 나머지는 디스크에 남는다. 즉 디스크가 RAM의 보조기억장치처럼 작동한다.
    
    ⇒ RAM + 디스크(보조기억장치) ⇒ 하나의 크고 빠른 기억장치(가상메모리)
    
    - 프로세스는 가상 주소를 사용하고, 데이터를 사용할 때 실제 주소로 변환
        - MMU(메모리관리장치)에 의해 변환
    - 페이지 테이블로 관리됨 (가상 주소-실제 주소 매핑, 프로세스 주소 정보)
    - 속도 향상을 위해 캐시 계층인 **TLB** 사용
        - 페이지 테이블에 있는 리스트를 보관해 CPU가 페이지 테이블까지 가지 않도록 해줌
        
        ### 스와핑
        
        가상 메모리에는 존재하지만 실제 RAM에는 없는 데이터에 접근할 경우 페이지 폴트 발생. 이때 가상 메모리에서 페이지를 찾아 RAM에 올림
        
        1. CPU는 물리 메모리를 확인해 해당 페이지가 없으면 트랩 발생시켜 운영체제에 알림
        2. 운영체제는 CPU의 동작을 잠시 멈춤 (소프트웨어 인터럽트)
        3. 운영체제는 요구된 페이지를 가상 메모리에서 찾음
        4. RAM의 비어 있는 프레임에 해당 페이지 로드 
        5. 페이지 테이블 최신화
        6. 중단된 CPU 다시 시작
    
    ### 스레싱
    
    - 메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 발생하고, 메모리의 페이지 폴트율이 높아지는 현상
    - 페이지 폴트 발생 ⇒ CPU 이용률 낮아짐 ⇒ 운영체제는 가용성 높이기 위해 많은 프로세스를 메모리에 올림 ⇒ 악순환!
    - 해결 방법 : 메모리 늘리기, HDD를 SSD로 바꾸기, 작업 세트, PFF
        
        ### 작업 세트
        
        프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것
        
        ### PFF(Page Fault Frequency)
        
        페이지 폴트 빈도의 상한선과 하한선을 정해, 상한선 도달 시 프레임을 늘리고 하한선 도달 시 프레임을 줄임 
        
    
    ### 메모리 할당
    
    - 메모리에 프로그램을 할당할 때, 연속 할당과 불연속 할당으로 나뉨
        
        ### 연속 할당
        
        메모리에 연속적으로, 순차적으로 공간을 할당
        
        - **고정 분할 방식**
            - 메모리를 미리 나누어 관리
            - 융통성이 없고 내부 단편화 발생
        - **가변 분할 방식**
            - 매 시점마다 동적으로 메모리를 나누어 사용
            - 외부 단편화 발생
            - 최초적합, 최적적합, 최악적합
            
            ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%205.png)
            
        
        ### 불연속 할당
        
        현대 운영체제가 쓰는 방법
        
        ex) 페이징 기법, 세그멘테이션, 페이지드 세그멘테이션
        
        - **페이징 기법**
            - 메모리를 일정한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리의 서로 다른 위치에 프로세스 할당
            - 홀의 크기는 균일해짐
            - 주소 변환이 복잡
            
        - **세그멘테이션**
            - 메모리를 의미 단위인 세그먼트로 나누는 방식
            - 공유, 보안 측면에서 유리
            - 홀 크기 불균일
            
        - **페이지드 세그멘테이션**
            - 프로그램을 의미 단위 세그먼트로 나누는 방식
    
    ### 페이지 교체 알고리즘
    
    메모리는 한정되어 있기 때문에 스와핑이 자주 발생하고, 스와핑은 페이지 교체 알고리즘을 기반으로 일어남.
    
    ### 오프라인 알고리즘
    
    현재 할당하는 페이지와 먼 미래에 참조되는 페이지를 바꾸는 알고리즘 
    
    ⇒ but 미래에 사용되는 프로세스를 알 수 없음
    
    ### FIFO
    
    가장 먼저 온 페이지가 1순위로 교체됨. (교체 영역에 먼저 놓임)
    
    ### LRU (Least Recentle Used)
    
    참조가 가장 오래된 페이지를 우선으로 교체함.
    
    더 발전해 **NUR**(Not Used Recently) 알고리즘이 만들어짐.
    
    ### LFU (Least Frequently Used)
    
    참조 횟수가 가장 적은 페이지를 교페함. 
    

## 프로세스와 스레드

- **프로세스**
    - 컴퓨터에서 실행되고 있는 프로그램
    - CPU 스케줄링의 대상이 됨
    - 프로그램이 메모리에 올라가면 프로세스가 됨. (인스턴스화)
    - 이후 CPU 스케줄러에 따라 CPU가 프로세스 실행
    
- **스레드**
    - 프로세스 내 작업의 흐름

### 💡 프로세스와 컴파일 과정

- 프로그램 ⇒ 실행 파일
- 이 실행 파일을 열면 **프로세스**로 변환
- 컴파일러가 컴파일 과정을 통해 기계어로 번역해 실행할 수 있는 프로그램 파일 생성
    
    ### 컴파일 과정
    
    ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%206.png)
    
    - **전처리**
        - 주석 제거, 헤더 파일 병합해 매크로 치환
    - **컴파일러**
        - 오류 처리, 코드 최적화 작업
        - 어셈블리어로 변환
    - **어셈블러**
        - 어셈블리어를 목적 코드로 변환
    - **링커**
        - 프로그램 내 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합해 실행 파일 생성

### 💡 프로세스의 상태

### 생성 상태

프로세스가 생성된 상태로 이때 PCB 할당됨

fork(), exec() 함수를 통해 생성

- **fork()**
    - 부모 프로세스의 주소 공간을 복사하고, 새로운 자식 프로세스 생성
- **exec()**
    - 새롭게 프로세스 생성

### 대기 상태

메모리 공간 충분하면 메모리를 할당받고, 아니면 대기하면서 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

### 대기 중단 상태

메모리 부족으로 일시 중단된 상태 

### 실행 상태

CPU 소유권과 메모리를 할당받아 수행 중인 상태

### 중단 상태

어떤 이벤트 발생한 이후 기다리며 프로세스가 차단된 상태

### 일시 중단 상태

중단 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태

### 종료 상태

메모리와 CPU 소유권을 모두 놓고 가는 상태

### 💡프로세스의 메모리 구조

![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%207.png)

### 동적 할당 ⇒ 스택과 힙

- 동적 할당 : 런타임 단계에서 메모리 할당하는 것
- **스택**
    - 실행되는 함수 등에 의해 늘어나거나 줄어드는 메모리 영역
    - 함수 호출될 때마다 그 때의 환경 등 특정 정보 저장
    - 위 주소부터 할당됨
- **힙**
    - 동적 할당되는 변수를 담는 영역 (EX. 동적으로 관리되는 자료구조)
    - 아래 주소부터 할당됨

### 정적 할당 ⇒ 데이터 영역과 코드 영역

- 정적 할당 : 컴파일 단계에서 메모리 할당하는 것
- **데이터 영역**
    - BSS 세그먼트 : 전역 변수/static, const 선언된 0으로 초기화된, 혹은 초기화 아예 안 된 변수
    - Data 세그먼트 : 전역 변수/static, const 선언된 0 아닌 값으로 초기화된 변수
- **코드 영역**
    - 프로그램의 코드

### 💡 PCB (Program Control Block)

- 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터
- 프로세스 생성 시 운영체제가 PCB 생성
- 프로세스의 중요한 정보를 포함하므로 커널 스택의 가장 앞부분에서 관리
    
    ### 컨텍스트 스위칭
    
    - PCB를 교환하는 과정
    - 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
    - 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행
        
        ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%208.png)
        
        - 유휴시간과 캐시미스 발생
        - 스레드에서도 컨텍스트 스위칭 발생함.

### 💡 멀티프로세싱

동시에 두 가지 이상의 일을 수행할 수 있음. (병렬 처리)

### 웹 브라우저

⇒ 멀티 프로세스 구조를 가짐.

- 브라우저 프로세스 : 주소 표시줄, 주요 버튼 등을 담당, 네트워크 요청, 파일 접근 권한 등 담당
- 렌더러 프로세스 : 웹사이트에서 보이는 모든 부분을 제어
- 플러그인 프로세스 : 웹사이트에서 사용하는 플러그인 제어
- GPU 프로세스 : GPU 이용해 화면 그리는 부분 제어

### IPC

프로세스끼리 공유하는 데이터를 관리하는 매커니즘

메모리가 완전히 공유되는 스레드보다는 속도 느림

종류 : 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐 

- **공유 메모리**
    - 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해 통신
    - IPC 방식 중 가장 빠름
    - 동기화 필요
    - 하드웨어 관점에서는 RAM을 가리킴
- **파일**
    - 디스크에 저장된 데이터 혹은 파일 서버에서 제공한 데이터를 기반으로 프로세스 간 통신
- **소켓**
    - 네트워크 인터페이스를 통해, 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 전송하는  데이터
    - TCP/UDP
- **익명 파이프**
    
    ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%209.png)
    
    - 파이프라는 임시공간을 기반으로 프로세스 간 데이터 공유
    - 단방향 방식의 파이프!
    - 부모-자식 프로세스 간에만 사용 가능
- **명명된 파이프**
    - 파이프 서버와 여러 파이프 클라이언트 간 통신을 위한 단방향/양방향 파이프
- **메시지 큐**
    - 메시지를 큐 구조로 관리하는 것
    

### 💡 스레드와 멀티스레딩

- **스레드**
    - 프로세스의 실행 가능한 가장 작은 단위
    - 즉 프로세스를 쪼갠 것..
    - 프로세스는 코드, 데이터, 스택, 힙을 각각 생성하지만 스레드는 여러 개의 스레드가 하나의 코드, 데이터, 스택, 힙을 공유함
    
- **멀티스레딩**
    - 프로세스 내 작업을 여러 개의 스레드로 처리하는 기법
    - 스레드끼리 자원을 공유하므로 효율적
    

### 💡 공유 자원과 임계 영역

- **공유 자원**
    - 시스템 안에서 각 프로세스, 스레드가 모두 접근할 수 있는 자원, 변수
    - 두 개 이상의 프로세스가 동시에 접근하는 상황 ⇒ **경쟁 상태**
    
- **임계 영역**
    - 둘 이상의 프로세스, 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
    - 해결 방법 : 상호 배제, 한정 대기, 융통성
        - **상호 배제** : 한 프로세스가 임계 영역에 들어가면 다른 프로세스는 들어갈 수 없다.
        - **한정 대기** : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안된다.
        - **융통성** : 한 프로세스가 다른 프로세스의 일을 방해하면 안 된다.
        

### 💡 교착 상태

둘 이상의 프로세스가 서로의 자원을 기다리며 중단된 상태

- **원인**
    - 상호 배제
    - 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청
    - 비선점 : 다른 프로세스의 자원을 강제로 가져올 수 없음
    - 환형 대기 : 서로가 서로의 자원을 요구하는 상황
    
- **해결 방법**
    1. 자원 할당 시 애초에 조건이 성립되지 않도록 설계
    2. 교착 상태 가능성이 없을 때만 자원 할당, 은행원 알고리즘 사용
    3. 교착 발생 시 사이클이 있는지 찾아보고, 관련 프로세스를 하나씩 지움
    4. 교착 발생 시 사용자가 작업을 종료 

## CPU 스케줄링 알고리즘

- CPU 스케줄러는 알고리즘에 따라 프로세스에서 해야 할 일을 스레드 단위로 CPU에 할당
- 프로그램이 실행될 때 어떤 프로그램에 CPU 소유권을 줄 것인지 결정
- CPU 이용률 높게, 주어진 시간 내에 많은 일을 하게, 준비 큐에 있는 프로세스는 적게, 응답 시간은 짧게 하는 것이 목표
    
    ### 💡 비선점형 방식
    
    - 프로세스가 스스로 CPU 소유권을 포기하는 방식
    - 강제로 프로세스 중지 X ⇒ 컨텍스트 스위칭으로 인한 부하 적음
        
        ### FCFS
        
        가장 먼저 온 것을 먼저 처리하는 알고리즘 
        
        - 프로세스 수행 시간이 길면 준비 큐에서 오래 기다리는 현상 발생
        
        ### SJF
        
        실행시간이 가장 짧은 프로세스를 먼저 처리하는 알고리즘
        
        - 긴 시간이 걸리는 프로세스가 실행되지 않는 현상 발생
        
        ### 우선순위
        
        SJF의 단점을 보완해 오래된 작업일수록 우선순위를 높이는 방법을 채택
        
    
    ### 💡 선점형 방식 ⇒ 현대 운영체제
    
    - 현재 사용 중인 프로세스를 중단시키고 강제로 다른 프로세스에 CPU 소유권 할당하는 방식
        
        ### 라운드 로빈
        
        각 프로세스에 동일한 할당시간을 주고 시간 내에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘 
        
        ### SRF
        
        실행시간이 짧은 프로세스를 우선 처리하는데(SJF), 중간에 더 짧은 작업이 들어오면 수행 중인 프로세스를 중지하고 더 짧은 프로세스를 수행하는 알고리즘
        
        ### 다단계 큐
        
        우선순위에 따른 준비 큐를 여러 개 사용 
        
        각 큐마다 다른 스케줄링 알고리즘 적용 
        
        ![Untitled](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20255079b0d65f47f7afe1ee61945050c2/Untitled%2010.png)
        
        - 큐 간 프로세스 이동이 불가능해 스케줄링 부담 적음
        - 유연성은 떨어짐
