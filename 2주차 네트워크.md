# 2주차 네트워크

## 네트워크의 기초

### 네트워크

- **노드**와 **링크**가 연결되어 있고 리소스를 공유하는 집합
- **노드** : 데이터를 다룰 수 있는 네트워크 장치(서버, 라우터, 스위치 등)
- **링크** : 유선 / 무선

### 💡 네트워크 분류

규모를 기반으로 분류 

1. **LAN (Local Area Network)**
    - 근거리 통신망 (같은 건물, 캠퍼스 등)
    - 전송 속도 빠름
    - 혼잡도 낮음
    
2. **MAN (Metropolitan)**
    - 대도시 지역 네트워크 (도시 범위)
    - 전송 속도 평균
    - LAN보다 혼잡
    
3. **WAN (Wide)**
    - 광역 네트워크 (국가, 대륙 범위)
    - 전송 속도 낮음
    - 혼잡도 가장 높음
    

### 💡 좋은 네트워크의 조건

- 많은 **처리량**을 처리할 수 있어야 함.
- **지연 시간**이 짧아야 함.
- 장애 빈도가 적어야 함.
- 좋은 보안을 갖춰야 함.

### ✔️ 처리량 (Throughput)

- 링크 내에서 성공적으로 전달된 데이터의 양
- 처리한 트래픽의 양
- bps 단위 사용 (초당 전송/수신되는 비트 수)
- 트래픽, 장치 간 대역폭, 에러, 하드웨어 스펙에 영향 받음

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/8a7adbe2-3c50-4209-a640-7790ea2fbcca/Untitled.png)

<aside>
💡 **대역폭**
네트워크 연결을 통해 흐를 수 있는 최대 비트 수
*⇒ 대략적인 최대 동시 접속자 수 유추의 척도*

</aside>

### ✔️ 지연 시간 (Latency)

- 요청이 처리되는 시간
- 대역폭을 크게 설정하면 지연시간을 짧게 만들 수 있음
- 매체 타입(유/무선), 패킷 크기, 라우터의 패킷 처리 시간에 영향 받음

<aside>
💡 **패킷**
네트워크를 통해 전송되는 데이터의 조각
데이터는 패킷 단위로 쪼개서 보내진다.

</aside>

### 💡 네트워크 토폴로지와 병목 현상

### ✔️ 네트워크 토폴로지

- 노드와 링크의 배치 방식. 즉, 노드, 링크의 연결 형태
- **트리, 버스, 스타, 링, 메시 토폴로지**

1. **트리 토폴로지 (계층형 토폴로지)**
    
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/f2aee0df-4de4-44e3-b5eb-946645270191/Untitled.png)
    
    **장점**
    
    - 노드 추가, 삭제가 쉬움
    - 네트워크 신뢰도 높음
    
    **단점**
    
    - 특정 노드에 트래픽이 집중되면 하위 노드에 영향을 끼침
    
2. **버스 토폴로지**
    
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/c1875adb-f6e4-4cda-9359-aad72713ef34/Untitled.png)
    
    중앙 통신 회선 하나에 여러 개의 노드 연결. 근거리 통신망인 LAN에서 사용.
    
    **장점**
    
    - 설치 비용 적고 신뢰성 우수
    - 구조가 간단해 확장이 쉬움
    - 한 노드가 죽어도 망에는 지장이 없음
    
    **단점**
    
    - 데이터 양이 많으면 병목현상 발생
    - 중앙 회선 장애 발생 시 전체 네트워크에 영향을 받음
    - 스푸핑 가능
        
        <aside>
        💡 **스푸핑**
        송신부의 패킷을 생뚱맞은 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시켜 악의적인 특정 노드에 패킷이 거쳐가도록 하는 것
        
        </aside>
        
3. **스타 토폴로지**

    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/36197f0c-1900-4bb7-b49c-898af725f163/Untitled.png)
    
    중앙에 있는 노드에 다른 노드가 모두 연결됨. 고속 네트워크에 적합
    
    **장점**
    
    - 노드 추가가 쉽고, 에러 탐지에 용이
    - 중앙을 제외한 다른 노드에 장애 발생해도 네트워크 사용 가능
    
    **단점**
    
    - 중앙 노드에 장애 발생 시 전체 네트워크 사용 불가능
    - 설치 비용이 비쌈
    
4. **링형 토폴로지**

    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/85beb2bb-6b8a-40e1-9898-ab25914ce389/Untitled.png)
    
    인접한 노드끼리 연결되어 하나의 고리로 통신하는 구조
    
    **장점**
    
    - 노드가 추가되어도 네트워크 손실이 거의 없음
    - 충돌이 적게 발생
    - 노드 고장 발견이 쉬움
    
    **단점**
    
    - 네트워크 구성 변경 어려움
    - 회선에 장애 발생 시 전체 네트워크에 영향이 큼
    
5. **메시 토폴로지**

    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/8a52df9b-770e-4cf6-837c-d4f67e3885a9/Untitled.png)
    
    **장점**
    
    - 한 노드에 장애 발생해도 다른 경로 존재 → 지속적인 네트워크 사용 가능
    - 트래픽 분산 처리 가능
    
    **단점**
    
    - 노드 추가 어려움
    - 구축 비용, 운용 비용 비쌈

### ✔️ 병목 현상

- 하나의 구성 요소로 인해 전체 시스템의 성능, 용량이 제한을 받는 현상
- **원인**
    - 네트워크 대역폭
    - 네트워크 토폴로지
    - 서버 CPU, 메모리 사용량
    - 비효율적 네트워크 구성
    
- 어떤 네트워크 토폴로지인지 확인하고, 어떤 경로로 이루어져 있는지 확인해야 해결 가능

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/80db1a16-e750-4499-be58-e00549cbb6fc/Untitled.png)

### 💡 네트워크 성능 분석 명령어

네트워크 관련 테스크, 네트워크와 무관한 테스트를 시행해 ‘네트워크 때문에 발생한 문제점’임을 확인하고 성능 분석 진행해야 함.

- **ping (Packet INternet Groper)**
    
    `ping [IP 주소 or 도메인 주소]`
    
    대상 노드에 일정 크기의 패킷을 전송하는 명령어 
    
    - 노드가 패킷을 잘 받았는지
    - 받는데 시간은 얼마나 걸렸는지
    
    - 대상 노드에 네트워크가 잘 연결되어 있는지
    
    ICMP 프로토콜을 통해 동작 → 해당 프로토콜을 지원하지 않는 기기는 실행 X
    
- **netstat**
    
    접속되어 있는 서비스들의 네트워크 상태 표시
    
    서비스의 포트가 열려있는지 확인할 때 사용
    
    - 네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 등 리스트
    
- **nslookup**
    
    DNS 관련 내용 확인할 때 사용 
    
    특정 도메인에 매핑된 IP 확인하기 위해 사용 
    
- **tracert (윈도우)**
    
    목적지 노드까지 네트워크 경로 확인할 때 사용 
    
    - 어느 구간에서 응답 시간 느려지는지

### 💡 네트워크 프로토콜 표준화

**네트워크 프로토콜 (통신 규약)**

다른 장치끼리 데이터 주고받기 위해 설정된 공통된 인터페이스 

표준화 단체에서 정해짐. (IEEE 또는 IETF)

## TCP/IP 4계층 모델

인터넷 프로토콜 스위트 : 프로토콜의 집합

⇒ **TCP/IP 4계층 모델** 혹은 **OSI 7계층 모델**로 설명 가능

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/13daebdb-11ce-4a52-a6cd-d076fe1c7ac4/Untitled.png)

- **애플리케이션 계층 (상위 계층)**
    - 서비스를 실질적으로 사람에게 제공하는 계층
    - ex) HTTP, FTP, SSH, DNS 등
    
- **전송 계층**
    - 송신자와 수신자를 연결하는 통신 서비스 제공
    - 애플리케이션-인터넷 계층 간 데이터 전달에 중계 역할
    - ex) TCP, UDP 등
        - **TCP**
            - 패킷 사이 순서 보장
            - 연결지향 프로토콜로, 수신 여부를 확인하며 신뢰성 있는 데이터 전달
            - 가상회선 패킷 교환 방식 사용
            - **TCP 연결 성립 과정**
                - 신뢰성 확보를 위해 3-웨이 핸드셰이크 과정 진행
                    1. **SYN 단계**
                        
                        클라이언트가 서버에게 접속을 요청하는 SYN 플래그 보냄
                        
                    2. **SYN + ACK 단계**
                        
                        서버는 클라이언트의 SYN을 받고, SYN + ACK 플래그를 클라이언트에게 전송
                        
                    3. **ACK 단계**
                        
                        SYN + ACK 상태를 확인한 클라이언트는 서버에 ACK를 보내고 연결이 성립됨
                        
            - **TCP 연결 해제 과정**
                - 4-웨이 핸드셰이크 과정 발생
                    1. 클라이언트가 연결을 종료하겠다는 FIN 플래그 전송
                    **클라이언트 → FIN_WAIT_1** 상태 진입
                    2. FIN을 받은 서버는 확인 메시지 ACK를 클라이언트에 전송
                    **서버 → CLOSE_WAIT 상태** 진입 → 클라이언트가 ACK 받으면 **FIN_WAIT_2** 상태 진입
                    3. 닫을 준비가 된 후, 서버가 클라이언트에 FIN 플래그 전송
                    4. 해지 준비가 된 클라이언트는 **TIME_WAIT** 상태가 되고 ACK를 서버에 전송해 서버는 **CLOSED** 상태 진입
                    
                    ⇒ 클라이언트는 일정 시간 대기 후 연결이 닫히고, 클라이언트-서버 간 모든 연결 해제
                    
            
            [TCP와 3-Way, 4-Way Handshake란? (개념/ 동작 방식)](https://jeongkyun-it.tistory.com/180)
            
        - **UDP**
            - 패킷을 순차적으로 보내더라도 서로 다른 통신 선로를 통해 전달될 수 있음.
            - 패킷이 도착하는 순서대로 데이터 재결합하므로 순서 보장 X
            - 비연결지향 프로토콜로, 신뢰성 떨어짐.
            - 데이터그램 패킷 교환 방식 사용
            
        - **가상회선 패킷 교환 방식**
            - 각 패킷에 가상회선 식별자 포함
            - 모든 패킷이 전송되면 가상회선 해제
            - 모든 패킷이 같은 경로로 전송됨.
            
        - **데이터그램 패킷 교환 방식**
            - 패킷마다 라우터가 최적의 경로를 선택해 전송
            
- **인터넷 계층**
    - 장치로부터 받은 네트워크 패킷을 목적 IP 주소로 전송하기 위해 사용
    - 상대방이 데이터를 받았는지는 보장하지 않는 비연결형적 특징을 가짐
    - ex) IP, ARP, ICMP 등
    
- **링크 계층**
    - 실질적으로 데이터를 전달하고 장치 간 신호를 주고받는 규칙을 정함
    - 물리 계층과 데이터 링크 계층으로 나누기도 함
        - **물리 계층**
            - 무선, 유선 LAN을 통해 0과 1로 이루어진 데이터를 보냄
        - **데이터 링크 계층**
            - 이더넷 프레임을 통해 에러 확인, 흐름 제어, 접근 제어 담당
    - ex) 전선, 광섬유, 무선 등
    
    ### 유선 LAN
    
    - IEEE802.3 프로토콜을 따름
    - **전이중화 통신** 사용
        - 양쪽 장치가 동시에 송수신할 수 있는 방식
    - 대표적으로 **트위스트 페어 케이블, 광섬유 케이블** 사용
        - **트위스트 페어 케이블**
            
            하나의 케이블처럼 보이지만 실제로는 여덟 개의 구리선을 두 개씩 꼬아 묶은 케이블
            
        - **광섬유 케이블**
            
            레이저를 이용해 통신하므로 구리선보다 향상된 장거리 및 고속 통신 가능
            
    
    ### 무선 LAN
    
    - IEEE802.11 프로토콜을 따름
    - **반이중화 통신** 사용
        - 양쪽 장치가 동시에 통신할 수 없고, 한 번에 한 방향만 통신할 수 있는 방식
    - 공기에 주파수를 쏴서 무선 통신망 구축
    - **2.4GHz 대역** 또는 **5GHz 대역** 중 하나를 사용해 구축
        - **2.4GHz 대역**
            
            장애물에 강하지만, 전파 간섭 자주 발생
            
        - **5GHz 대역** (사용 권장)
            
            사용 가능한 채널 수가 많고 동시에 사용 가능
            
    - 와이파이, BSS, ESS

### 이더넷 프레임

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/652cac59-0660-4cf5-ae58-d4db486e5bac/Untitled.png)

- Premble : 이더넷 프레임의 시작을 알림
- SFD : 다음 바이트부터 MAC 주소 시작됨을 알림
- DMAC/SMAC : 수신/송신 MAC 주소
- EtherType : IP 프로토콜 정의 (ex. IPv4 or IPv6)
- Payload : 상위 계층 프로토콜로부터 캡슐화된 데이터
- CRC : 에러 확인 비트

### 💡 계층 간 데이터 송수신 과정

- **캡슐화 (상위→하위)**
    - 상위 계층 헤더와 데이터를 하위 계층 데이터 부분에 포함시킨 후 해당 계층의 헤더를 삽입하는 과정
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/11e655d2-d469-484e-bd35-bf423f4b15a5/Untitled.png)
    
    - **애플리케이션 → 전송계층**
        - TCP(L4) 헤더 추가
        - ‘세그먼트’ 또는 ‘데이터그램’화
    - **전송 → 인터넷**
        - IP(L3) 헤더 추가
        - ‘패킷’화
    - **인터넷 → 링크**
        - 프레임 헤더, 프레임 트레일러 추가
        - ‘프레임’화
        
- **비캡슐화 (하위→상위)**
    - 각 계층의 헤더 부분을 제거하는 과정
    - 캡슐화의 과정을 반대로..
    - 프레임화된 데이터 → 패킷화 → 세그먼트화 → 메시지화
    - 최종적으로 사용자에게 메시지로 전달됨

### 💡 PDU (Protocol Data Unit)

- 계층 간 데이터 전달될 때, 한 데이터 덩어리의 단위
- **헤더**(제어 관련 정보 포함) + **페이로드** (데이터) 로 구성
- 각 계층마다 명칭 다름
    - 애플리케이션 : 메시지
    - 전송 : 세그먼트(TCP), 데이터그램(UDP)
    - 인터넷 계층 : 패킷
    - 링크 계층 : 프레임(데이터 링크 계층), 비트(물리 계층)
    

## 네트워크 기기

- 상위 계층을 처리하는 기기 → 하위 계층도 처리 가능
- **스위치** : 여러 장비 간 데이터 통신이 가능하도록 하는 네트워크 기기

### 💡 애플리케이션 계층 처리 기기 → L7 스위치

- **L7 스위치**
    - 클라이언트의 요청들을 여러 서버로 나누어 서버 부하를 방지하는 역할
    (로드밸런서)
    - 장애가 발생한 서버는 **헬스 체크**를 통해 트래픽 분산 대상에서 제외
    - URL, 서버, 캐시, 쿠키를 기반으로 트래픽 분산
    
- **헬스 체크**
    - 전송 주기, 재전송 횟수 등을 설정해 반복적으로 서버에 요청을 보내는 것
    - 요청이 정상적으로 이루어졌다면 문제 없는 서버로 판별

- **로드밸런서를 이용한 서버 이중화**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/7d179d44-52ae-46bc-98b2-bc0af54fba86/Untitled.png)

로드밸런서가 가상 IP를 제공하고 2대 이상의 서버를 기반으로 서빙함

### 💡 인터넷 계층 처리 기기 → 라우터, L3 스위치

- **라우터**
    - 라우팅(네트워크 안에서 데이터를 보낼 때 최적 경로를 선택)을 하는 장비
    - 여러 네트워크를 연결, 분할, 구분시켜주는 역할
    - 소프트웨어 기반 라우팅 / 하드웨어 기반 라우팅을 하는 것으로 구분
    
- **L3 스위치**
    - L2 스위치 기능 + 라우팅 기능
    - 하드웨어 기반 라우팅 담당

[스위치, 라우터의 차이](https://velog.io/@jihoon97/스위치-라우터의-차이)

### 💡 데이터 링크 계층 처리 기기 → L2 스위치, 브리지

- **L2 스위치**
    - 장치들의 MAC 주소를 MAC 주소 테이블로 관리
    - 연결된 장치로부터 패킷 왔을 때 패킷 전송 담당
    - IP 주소 기반 라우팅 불가능
    - 패킷의 MAC 주소 읽고 스위칭하는 역할

- **브리지**
    - 두 개의 LAN을 상호 접속할 수 있도록 하는 연결 장치
    - 장치의 MAC 두소를 MAC 주소 테이블로 관리
    - 서로 다른 LAN 등으로 이루어진 하나의 통신망을 구축할 때 사용
    

[통신 장비 - 02. 데이터링크 계층 Bridge, Switch](https://greencloud33.tistory.com/34)

### 💡 물리 계층 처리 기기 → NIC, 리피터, AP

- **NIC (Network Interface Card)**
    - LAN 카드라고 부름 → 고유의 식별번호인 MAC 주소가 있음
    - 2대 이상의 컴퓨터 네트워크 구성 시 사용
    - 컴퓨터 내에 설치하는 확장 카드
    
- **리피터**
    - 약해진 신호가 들어올 때 이를 증폭시켜 다른 쪽으로 전달
    - 패킷이 더 멀리 갈 수 있음
    - 광케이블 보급으로 현재는 잘 사용 X
    
- **AP (Access Point)**
    - 패킷을 복사하는 기기
    - AP에 유선 LAN 연결해 다른 장치에서 무선 LAN 기술로 네트워크 연결 가능

## IP 주소

컴퓨터 - 컴퓨터 간 통신 

⇒ IP 주소에서 ARP를 통해 MAC 주소를 찾고, 이 MAC 주소를 기반으로 통신

### 💡 ARP (Address Resolution Protocol)

- IP와 MAC 주소의 다리 역할을 하는 프로토콜
- IP 주소 (가상 주소) ⇒ MAC 주소 (실제 주소) 로 변환
- 반대과정은 RARP를 통해 이루어짐

### 💡 홉바이홉 통신

- IP 주소를 통해 통신하는 과정
- 수많은 서브네트워크 내 라우터의 라우팅 테이블 IP를 기반으로 패킷을 전달해나가며 최종 목적지까지 도달

- **라우팅 테이블**
    - 확인 방법 : `netstat -r`
    - 목적지 정보, 목적지로 가는 방법이 들어있는 리스트
    - 게이트웨이 + 모든 목적지에 대해 그곳으로 가기 위한 다음 라우터의 정보
    
- **게이트웨이**
    - 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간 통신을 가능하게 하는 관문 역할
    - 한 네트워크에서 다른 네트워크로 이동하기 위해 거쳐야 하는 지점
    - 서로 다른 네트워크 상 통신 프로토콜 변환하는 역할
    - 거치는 게이트웨이의 수 ⇒ 홉 수

### 💡 IP 주소 체계

- **IPv4** : 32비트 (8비트 단위로 점 찍어 표기)
    
    ⇒ `123.45.67.89`
    
- **IPv6** : 64비트 (16비트 단위로 점 찍어 표기)
    
    ⇒ `2001:db8::ff00:42:8329`
    

### 초기 → 클래스 기반 할당 방식

![호스트 주소 : 컴퓨터에 부여하는 주소](https://prod-files-secure.s3.us-west-2.amazonaws.com/893b8654-e780-476c-b862-9eb07e2ddfa7/2e7748ad-7efc-4711-81dc-0ec707606b03/Untitled.png)

호스트 주소 : 컴퓨터에 부여하는 주소

클래스 A,B,C ⇒ 일대일 통신으로 사용. 보통 이 세 가지를 사용.

클래스 D ⇒ 멀티캐스트 통신

클래스 E ⇒ 예비용

- **A 클래스**
    - 구분 비트 : 0 (처음 한 비트는 항상 0)
    - 첫 바이트가 1~126 사이 숫자로 시작
- **B 클래스**
    - 구분 비트 : 10 (처음 두 비트는 항상 10)
    - 첫 바이트가 128~191 사이 숫자로 시작
- **C 클래스**
    - 구분 비트 : 110 (처음 세 비트는 항상 110)
    - 첫 바이트가 192-223 사이 숫자로 시작

[IP 주소의 클래스 기반 할당 방식](https://velog.io/@dlehdus97/IP-주소의-클래스-기반-할당-방식)

[[네트워크] Classful Addressing( 클래스 기반 주소 지정 )](https://alsrb0819.tistory.com/2#google_vignette)

⇒ 사용하는 주소보다 버리는 주소가 많음

### DHCP

- IP 주소를 자동으로 할당하기 위한 네트워크 관리 프로토콜
- 인터넷에 접속할 때마다 자동으로 IP 주소 할당 가능

### NAT

- 패킷이 전송되는 동안 패킷의 IP 주소 정보를 수정해 다른 주소로 매핑
- 여러 대의 호스트가 하나의 공인 IP 주소를 사용해 인터넷에 접속 가능
    
    ⇒ 사설 IP ↔ 공인 IP
    
- 내부 네트워크 보안 가능
- 접속하는 호스트 수에 따라 속도 느려질 수 있음

## HTTP

애플리케이션 계층으로, 웹 서비스 통신에 사용

### 💡 HTTP/1.0

- 한 연결 당 하나의 요청을 처리
- 매번 데이터를 요청하고 수신할 때마다 새로운 TCP 세션 열어야 함
    
    ⇒ 연결할 때마다 **RTT(패킷 왕복 시간)** 증가
    
    - **RTT 증가 해결 방법**
        - 이미지 스플리팅
        - 코드 압축
        - 이미지 Base64 인코딩
    

### 💡 HTTP/1.1

- TCP 3-웨이 핸드셰이크가 한 번만 발생하고 keep-alive 옵션으로 여러 개의 데이터를 송수신할 수 있음

**단점**

- 요청할 리소스 개수에 비례해 대기 시간이 길어짐
- 무거운 헤더 구조 (많은 메타데이터가 들어있고 압축이 불가능)

### 💡 HTTP/2

- 이전보다 지연 시간 짧아지고 응답시간 빨라짐
- 멀티플렉싱, 헤더 압축, 서버 푸시, 요청 우선순위 처리 지원
    - **멀티플렉싱**
        - 여러 스트림을 사용해 데이터 송수신 (병렬적인 스트림)
        - 애플리케이션에서 받은 메시지를 독립된 프레임으로 잘라서 송수신
        → 송수신 이후 재조립
        - HOL Blocking 문제 해결 가능
        
    - **헤더 압축**
        - HPACK 압축 형식 (허프만 코딩 압축 알고리즘 사용)
        
    - **서버 푸시**
        - 클라이언트 요청 없이 서버가 바로 리소스를 푸시 가능
    

### 💡 HTTPS

- 애플리케이션과 전송 계층 사이에 **SSL/TLS**라는 신뢰 계층을 넣어 **통신을 암호화**
    - **SSL/TLS**
        - 전송 계층에서 보안을 제공하는 프로토콜
        - 네트워크 상 인터셉터 방지
        - 보안 세션을 기반으로 데이터 암호화
        
    - **보안 세션**
        - 핸드셰이크를 통해 보안 세션 생성
        - 클라이언트가 서버로 사이퍼 슈트 전달
        → 서버는 사이퍼 슈트의 암호화 알고리즘 리스트 제공 가능한지 확인
        → 인증 매커니즘 진행 (서버에서 클라이언트로 인증서 보냄)
        → 해싱 알고리즘 등으로 암호화된 데이터 송수신
        
- HTTPS를 사용하면 SEO(검색 엔진 최적화)에도 도움이 됨
    - **SEO를 위한 방법**
        - 캐노니컬 설정
            
            `<link rel="canonical" href="https://example.com/page2.php" />`
            
        - 메타 설정
        - 페이지 속도 개선
        - 사이트맵 관리
        
- **구축 방법**
    1. CA에서 구매한 인증키를 기반으로 구축
    2. 서버 앞단에 HTTPS를 제공하는 로드밸런서 두기
    3. 서버 앞단에 HTTPS를 제공하는 CDN 두기
    

[[Server] HTTPS의 개념과 인증서 발급 및 서버 구현](https://velog.io/@sominpark/Server-HTTPS의-개념과-인증서-발급-및-서버-구현)

### 💡 HTTP/3

- 기존 HTTP와 다르게 UDP 기반의 QUIC이라는 프로토콜 위에서 동작
- 3-웨이 핸드셰이크 과정을 거치지 않아도 됨
- 첫 연결 설정에 1-RTT 만 소요
