# 데이터베이스의 기본

- **데이터베이스** : 일정한 규약을 통해 구조화되어 저장되어 있는 데이터의 모음
- **DBMS** : 데이터베이스를 제어, 관리하는 통합 시스템

⇒ 각 DBMS마다 정의된 쿼리 언어로 DB 관리 가능 

ex) MySQL이라는 DBMS를 통해 데이터베이스를 관리하며, Node.js 등의 응용 프로그램으로 데이터베이스 안의 데이터를 꺼내 활용할 수 있음

## ✅ 엔터티

- 여러 개의 속성을 지닌 명사
- 서비스의 요구사항에 맞춰서 필요한 속성만을 취함.
- ex ) 회원 엔터티 ⇒ 속성 : 이름, 아이디, 주소, 전화번호
    
    
    ### ✔️ 약한 엔터티와 강한 엔터티
    
    - A 엔터티는 B 엔터티에 종속적인 존재로, A 혼자서 존재하지 못한다면
    ⇒ A : 약한 엔터티, B : 강한 엔터티
    

## ✅ 릴레이션

- 데이터베이스에서 정보를 구분해 저장하는 기본 단위
- 엔터티에 관한 모든 속성 데이터를 릴레이션 하나에 담아 관리
    
    
    ### ✔️ 테이블과 컬렉션
    
    - **관계형 데이터베이스** ex) MySQL
        - 릴레이션의 명칭 : ‘**테이블**’
        - 레코드 - 테이블 - 데이터베이스 구조
         ⇒ 레코드가 쌓여서 테이블이 되고, 테이블이 쌓여 데이터베이스가 됨

    - **NoSQL 데이터베이스**  ex) MongoDB
        - 릴레이션의 명칭 : ‘**컬렉션**’
        - 도큐먼트 - 컬렉션 - 데이터베이스 구조
    
    

## ✅ 속성

- 릴레이션에서 관리하는 정보로, 고유한 이름을 가지고 그 내용이 구체적임

## ✅ 도메인

- 각 속성들이 가질 수 있는 값들의 집합
- ex ) **성별** 속성의 도메인은 **{ 남, 여 }** 라는 집합이 됨.

## ✅ 필드와 레코드

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/20e300c2-eb03-4dd4-b780-aa9a5b9b2149)


- 회원 엔터티는 member라는 테이블로 표현됨
- 이름, 아이디, 주소, 전화번호 속성을 가지고 있고 이 속성은 필드로 표현됨
- 테이블에 쌓이는 행 단위의 데이터를 레코드(튜플)라고 함

### ✔️ 필드 타입 (MySQL 기준)

- **숫자 타입**
    - **TINYINT**(1바이트), **SMALLINT**(2바이트), **MEDIUMINIT**(3바이트), **INT**(4바이트), **BIGINT**(8바이트)
    
- **날짜 타입**
    - **DATE** (3바이트) : 날짜 값  `YYYY-MM-DD`
    - **DATETIME** (8바이트) : 날짜 값 + 시간 값  `YYYY-MM-DD hh:mm:ss`
    - **TIMESTAMP** (4바이트) : 날짜 값 + 시간 값  `YYYY-MM-DD hh:mm:ss`
        
        ⇒ DATETIME과 달리 TIMESTAMP는 타임존을 기반으로 표시되기 때문에, 시스템의 타임존이 바뀌면 값이 그에 맞게 수정됨
        
    
- **문자 타입**
    - **CHAR과 VARCHAR  `CHAR/VARCHAR(최대 글자 수)`**
        - **CHAR** : 고정 길이 문자열
            - CHAR(30) 선언 ⇒ 10글자를 저장해도 30바이트로 저장됨
        - **VARCHAR** : 가변 길이 문자열
            - VARCHAR(30) 선언 ⇒ 10글자 저장하면 10바이트로 저장됨
        
    - **TEXT와 BLOB** ⇒ 큰 데이터 저장할 때 사용
        - **TEXT** : 큰 문자열 저장 ex) 게시판 본문 저장
        - **BLOB** : 이미지, 동영상 등 큰 데이터 저장
            - 보통은 서버에 파일을 올리고 그 경로를 VARCHAR로 저장
            
    - **ENUM과 SET  `ENUM/SET(’문자열’, ‘문자열’, ..)`**
        - 괄호 안의 문자열만 데이터 값으로 저장될 수 있고 그 외의 다른 값이 삽입될 경우 빈 문자열이 대신 삽입됨
        - ENUM : 문자열 리스트 중 하나의 값만 취할 수 있음
            - 저장되는 문자열은 0, 1 등의 숫자로 매핑됨
            - 최대 65,535개의 요소를 넣을 수 있음
        - SET : 문자열 리스트 중 여러 개의 값을 취할 수 있음
            - 최대 64개의 요소를 넣을 수 있음

## ✅ 관계

- 데이터베이스에는 여러 테이블이 존재하고, 서로 관계가 정의되어 있음
    
    ### ✔️ 1:1 관계
    
    - 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우
    - EX) 유저 (이름, 전화번호, 주소) - 유저 이메일 (이름, 이메일)
        
        ⇒ 각 유저마다 하나의 이메일 주소 존재 
        
    - 테이블 구조를 더 이해하기 쉽게 만들어 줄 수 있음
    - 그러나 유저 테이블 자체를 유저 (이름, 전화번호, 주소, 이메일) 로 구성하는 게 나을 수 있음
    
    ### ✔️ 1:N 관계
    
    - 하나의 레코드가 다른 테이블의 레코드 여러 개와 연결된 경우
    - EX) 팀 (이름, 국가) - 선수 (이름, 팀)
        
        ⇒ 한 팀이 여러 선수를 가질 수 있지만, 한 선수가 여러 팀에 속할 수는 없음
        
    - 관계형 데이터베이스에서 가장 많이 사용
    
    ### ✔️ N:M 관계
    
    - 여러 레코드가 다른 테이블의 레코드 여러 개와 연결된 경우
    - EX) 학생 (이름, ID) - 학생_강의(학생 ID, 강의 ID) - 강의 (이름, ID)
        
        ⇒ 학생도 강의를 많이 들을 수 있고, 강의도 여러 명의 학생을 포함할 수 있음
        
    - 보통 조인 테이블(학생_강의)을 생성해 학생 ID와 강의 ID를 묶어 관리함
    - 학생 테이블/강의 테이블과 학생_강의 테이블은 1:N / 1:M 관계를 가짐
        - 학생 한 명이 듣는 강의가 많아 학생_강의 테이블의 여러 레코드와 관계를 가질 수 있지만, 학생_강의의 레코드 하나가 학생 여러 명과 관계를 가질 수는 없다.

## ✅ 키

- DB에서 필요한 레코드를 다른 레코드와 구별할 수 있는 기준이 되는 속성
- 유일성 : 하나의 키값으로 레코드를 유일하게 식별할 수 있는 성질
- 최소성 : 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/eb092c09-c8ef-4011-8c97-bd7096b4db6c)

    
    ### ✔️ 기본키 (PK)
    
    - 테이블의 데이터 중 고유하게 존재하는 속성으로 지정
    - 다른 레코드와 그 값이 중복되면 안됨
    - 자연키와 인조키 중 골라서 설정 (주로 인조키로 설정됨)
        - **자연키** : 중복된 값들을 제외하며 중복되지 않는 속성을 자연스럽게 선택하는 키 ⇒ 언젠가 변할 수 있음
        - **인조키** : 인위적으로 ID를 부여해 생성한 키 ⇒ 변하지 않음
    
    ### ✔️ 외래키 (FK)
    
    - 다른 테이블의 기본키를 그대로 참조함
    - 테이블 간 관계를 생성함
        
        ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/1445b5a9-c54d-402d-8500-2744ffb1fcab)

        
    - **product의 외래키 : user_id** ⇒ client의 기본키 ID를 그대로 참조
        - 외래키는 중복되어도 ok
    
    ### ✔️ 후보키
    
    - 기본키가 될 수 있는 후보들
    
    ### ✔️ 대체키
    
    - 후보키 중 기본키로 지정되지 않은 나머지 키들
    
    ### ✔️ 슈퍼키
    
    - 유일성을 갖춘 키들

# ERD와 정규화 과정

## ✅ ERD(Entity Relationship Diagram)

- 릴레이션 간 관계들을 정의하는 다이어그램
- 시스템 요구사항을 기반으로 작성되며, ERD를 기반으로 DB를 구축함
- 관계형 데이터 구성에는 유용하지만, 비정형 데이터는 표현하기 어려움

## ✅ 정규화 과정

- 데이터베이스 이상 현상을 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
    - **데이터베이스 이상 현상**
        - 릴레이션 간 잘못된 종속 관계로 인해 발생하는 현상
        - **삽입 이상** : 특정 데이터가 존재하지 않아 중요 데이터를 DB에 삽입할 수 없음
        - **업데이트 이상** : 특정 데이터 업데이트 후에도 값이 정상적으로 변경되지 않음
        - **삭제 이상** : 특정 정보 삭제 시 원치 않는 정보도 삭제됨
        
- 정규형 원칙을 기반으로 정규형을 만들어가는 과정
- 기본 정규형 : 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형
- 고급 정규형 : 제4정규형, 제5정규형
    
    ### ✔️ 정규형 원칙
    
    - 같은 의미를 가지지만, 더 좋은 구조로 만들어야 함
    - 자료의 중복성은 감소해야 함
    - 독립적인 관계는 별개의 릴레이션으로 표현해야 함
    - 각 릴레이션은 독립적인 표현이 가능해야 함
    
    ### ✔️ 제1정규형
    
    - 릴레이션에 속하는 속성 값이 모두 단일한 원자 값으로 구성되어야 함
        
        ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/98da46fa-f8b2-40ca-a37c-c009a6441415)

        
    - 두 개 이상의 값을 가지는 반복 집합을 제거해야 함
    
    ### ✔️ 제2정규형
    
    - 제1정규형이면서, 기본키가 아닌 속성 모두가 기본키에 완전 함수 종속적
        
        ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/bae1a96a-7963-4110-a31d-ca92c7cdd431)

        
        - 기본키는 {ID, 수강명}
        - 기본키를 제외한 속성은 유저번호와 성취도
        - 유저번호는 기본키 중 ID만 알면 매칭됨
        - 성취도는 기본키 중 ID, 수강명 알면 매칭됨
    
    ### ✔️제3정규형
    
    - 제2정규형이면서, 기본키가 아닌 속성들 간 이행 종속성이 없어야 함
        
        ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/27cba891-73e3-410c-8b31-8bb07784bcb2)

        
        - ID를 알면 등급을 알 수 있고, 등급을 알면 할인율을 알 수 있음
        - 즉, ID를 알면 할인율을 알 수 있는 이행 종속성이 존재함
    
    ### ✔️ 보이스/코드 정규형
    
    - 제3정규형이면서, 모든 결정자가 후보키 집합에 속해야 함
        
        ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/f9de600b-4b17-44f6-b666-27d4156724f3)

        
        - 후보키 : {학번, 수강명}, {학번, 강사}
        - 강사 속성은 수강명 속성에 대한 결정자이지만, 강사 속성만 가지고 튜플을 식별할 수 없기 때문에 후보키가 될 수 없음 ⇒ 분리가 필요함
    
- 정규형 과정으로 테이블을 나눌 경우 성능이 좋아질 수도 나빠질 수도 있음
    
    ⇒ 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함!
    

# 트랜잭션과 무결성

## ✅ 트랜잭션

- DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 여러 개의 쿼리를 하나로 묶는 단위
- ACID 특징 : 원자성, 일관성, 격리성, 지속성
    
    ### ✔️ 원자성 (all or nothing)
    
    - 트랜잭션과 관련된 일이 모두 수행되었거나 아예 되지 않았거나를 보장
    - 트랜잭션 커밋 후 문제가 발생해 롤백하면, 트랜잭션 내 모든 작업이 수행되지 않음
        - **커밋**
            - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
            - 여러 쿼리가 하나의 트랜잭션 단위로 수행되고 수행 후 데이터베이스에 영구 저장됨
        - **롤백**
            - 에러 등의 이슈로 트랜잭션 전으로 돌리는 일
        
        ⇒ 커밋, 롤백으로 데이터 무결성이 보장됨 
        
        - **트랜잭션 전파**
    
    ### ✔️ 일관성
    
    - 허용된 방식으로만 데이터를 변경해야 하는 것
    
    ### ✔️ 격리성
    
    - 트랜잭션 수행 시 서로 끼어들지 못하는 것
        
       ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/961ccd71-e7c8-43b7-a00b-f774467a84fb)

        
        - **격리 수준**
            - **SERIALIZABLE**
                - 트랜잭션을 순차적으로 진행시키는 것
                - 격리성은 높지만 동시성은 떨어짐
            - **REPEATABLE_READ**
                - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음
            - **READ_COMMITTED**
                - 다른 트랜잭션이 커밋 완료한 데이터는 조회 허용
                - 한 트랜잭션이 접근한 행을 다른 트랜잭션이 수정 가능
                - 가장 많이 사용되는 격리 수준
            - **READ_UNCOMMITTED**
                - 하나의 트랜잭션이 커밋되기 전에 다른 트랜잭션에 노출됨
                - 가장 빠르다는 장점을 가짐
                - 데이터 무결성을 위해 사용하지 않는 것이 이상적
                
        - **격리 수준에 따라 발생하는 현상**
            - **팬텀 리드**
                - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 조회 결과가 다른 경우
            - **반복 가능하지 않은 조회**
                - 한 트랜잭션 내에서 같은 레코드를 두 번 이상 조회했는데, 그 값이 다른 경우
            - **더티 리드**
                - 반복 가능하지 않은 조회와 유사하며, 수정되었지만 아직 커밋되지 않은 상태라도 그 값이 다르게 나오는 경우
    
    ### ✔️ 지속성
    
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
    - DB에 시스템 장애가 발생해도 원 상태로 복구할 수 있는 회복 기능이 있어야 함
    - 이를 위해 체크섬, 저널링, 롤백 등의 기능 제공
        - **체크섬** : 중복 검사로 오류를 정정해 자료의 무결성 보호
        - **저널링** : 변경사항을 반영하기 전에 로그를 남기는 것

## ✅ 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- **개체 무결성** : 기본키로 선택된 필드는 빈 값을 허용하지 않음
- **참조 무결성** : 서로 참조 관계에 있는 두 테이블의 데이터는 일관된 값을 유지해야 함
- **고유 무결성** : 특정 속성이 고유한 값을 가지도록 조건 설정된 경우, 모두 고유한 값을 가져야 함
- **NULL 무결성** : 특정 속성 값에 NULL이 올 수 없다는 조건 주어진 경우, 그 속성 값은 NULL이 될 수 없음

# 데이터베이스의 종류

## ✅ 관계형 데이터베이스

- 표 형식으로 데이터를 저장하는 데이터베이스
- SQL 언어를 사용해 조작함
- MySQL, PostgreSQL, 오라클, SQL Server, ,MSSQL 등

## ✅ NoSQL 데이터베이스

- SQL을 사용하지 않는 데이터베이스
- MongoDB, redis 등

# 인덱스

- 데이터를 빠르게 찾을 수 있는 장치
- 보통 B-트리라는 자료 구조로 이루어짐

## ✅ B-트리

- 루프 노드, 리프 노드, 이 사이에 있는 브랜치 노드로 나뉨
    
   ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/7578da58-2edd-4d7b-8b03-8648ac455677)

    
    - 루트 노드부터 시작해 마지막 리프 노드에 도달해 해당 노드가 가리키는 데이터 포인터를 통해 결괏값 반환
    - 모든 값을 순차적으로 탐색하는 경우보다 훨씬 적은 양의 탐색 가능
    
    ### 인덱스가 효율적인 이유
    
    - 효율적 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조
    - 트리 깊이의 대수확장성
        - 리프 노드 수에 비해 트리 깊이는 매우 느리게 증가함
        - 깊이가 1 증가할 때마다 최대 인덱스 항목 수는 4배씩 증가

## ✅ 인덱스 만드는 방법

### ✔️ MySQL

- **클러스터형 인덱스** (테이블 당 하나)
    - primary key 옵션으로 기본키 만들기
    - 기본키로 만들지 않고 unique not null 옵션 붙이기
    
    ⇒ insert할 때 데이터가 정렬되고, 인덱스는 데이터 블록의 첫 번째 레코드 주소값을 갖게 됨
    
- **세컨더리 인덱스** (테이블 당 여러 개)
    - `create index` 명령어로 만들기

### ✔️ MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되고, 해당 키가 기본키로 설정됨
- 세컨더리키 부가적으로 설정해 기본키, 세컨더리키를 함께 쓰는 복합 인덱스 설정 가능

## ✅ 인덱스 최적화 기법

### 1. 인덱스는 비용이다

- 인덱스 리스트 → 컬렉션 순으로 탐색하고, 관련 읽기 비용 발생
- B-트리 효율적으로 조정하는 비용 발생
- 컬렉션 수정 시 인덱스도 수정되어야 함
    
    ⇒ 모든 필드에 인덱스를 다 설정하는 것은 비효율적
    
    ⇒ 컬렉션에서 가져와야 하는 양 많을 수록 인덱스 사용 비효율적
    

### 2. 항상 테스팅하라

- 서비스마다 사용하는 엔터티의 깊이, 테이블의 양 등이 다르므로 최적화 기법은 달라지고, 그렇기 때문에 항상 테스팅하는 것이 중요

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

- 복합 인덱스 : 여러 컬럼들을 조합해 인덱스를 생성하는 것
- 생성 순서에 따라 인덱스 성능이 달라짐
- ***같음 → 정렬 → 다중 값 → 카디널리티*** 순으로 생성하는 것이 베스트
- WHERE 조건문에 자주 사용되는 컬럼을 먼저 위치시키는 것이 좋음

# 조인의 종류

- 조인 : 두 개 이상의 테이블을 비교해 조인 조건에 맞으면  하나의 결과물을 만드는 것
- MySQL : `JOIN`
- MongoDB : `lookup`  ⇒ 성능 떨어지므로 되도록 사용 X
- 내부 조인, 왼쪽 조인, 오른쪽 조인, 합집합 조인 등

## ✅ 내부 조인

- 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
- 두 테이블 간 교집합
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/b7a7c8a1-a007-4967-99f3-351c1f815880)

    
- 오른쪽 테이블에 부서 아이디가 4인 부서는 존재하지 않으므로 왼쪽 테이블의 5번 값은 표기되지 않음

## ✅ 왼쪽 조인

- 왼쪽 테이블의 모든 행이 결과 테이블에 표기
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/a7db6afc-31e2-4aba-9d37-90a5464d165d)

    
- 왼쪽 테이블은 우선적으로 모두 표기되고, 이 중 오른쪽 테이블과 매칭되지 않는 부분은 NULL로 표기됨

## ✅ 오른쪽 조인

- 오른쪽 테이블의 모든 행이 결과 테이블에 표기
- 오른쪽 테이블의 키값으로 왼쪽 테이블의 키와 하나씩 대조해보며, 왼쪽 테이블과 매칭되지 않는 부분은 NULL로 표기됨

## ✅ 완전 외부 조인

- 두 테이블을 기반으로 조인 조건을 만족하지 않는 행까지 모두 표기
- 두 테이블을 합쳐 나올 수 있는 모든 조합을 표기

# 조인의 원리

## ✅ 중첩 루프 조인 (NLJ)

- 중첩 반복문과 같은 원리로 동작
- ex) A, B 테이블을 조인
    1. A 테이블의 첫 번째 행을 읽는다.
    2. B 테이블의 전체 행을 돌며 조건에 맞는 레코드를 찾는다.
    3. A 테이블의 다음 행을 읽는다.
    4. 같은 과정을 반복한다.
- 대용량 테이블에서는 비용이 많이 발생하므로 사용하지 않음
- 조인할 테이블을 작은 블록으로 나누어 블록 하나씩 조인하는 **블록 중첩 루프 조인** 방식도 존재

## ✅ 정렬 병합 조인

- 각 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 후 조인 작업 수행
- 조인 조건 컬럼에 인덱스가 없거나 출력해야 할 결과값이 많을 때 사용

## ✅ 해시 조인

- 해시 테이블 기반으로 조인
- 조인 조건이 ‘=’인 동등 조인에서만 사용 가능
- 보통 중첩 루프 조인보다 효율적

### 1. 빌드 단계

- 테이블 중 더 작은 테이블을 기반으로 해시 테이블을 빌드
- 조인에 사용되는 필드가 해시 테이블의 키로 사용됨

### 2. 프로브 단계

- 큰 레코드를 읽기 시작하며 각 레코드에서 해시 테이블 키와 일치하는 레코드를 찾아 결괏값으로 반환
- 각 테이블을 한 번씩만 읽기 때문에 중첩 루프 조인보다 보통은 성능이 더 좋음
