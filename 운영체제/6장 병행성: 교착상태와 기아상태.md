# 6장 병행성: 교착상태와 기아상태

## 교착상태의 원리

교착상태 : 프로세스들의 집합이 더 이상 진행하지 못하고 영구적으로 블록되어 있는 상태 

⇒ 각 프로세스가 어떤 사건을 기다리고 있고, 이 사건이 절대 발생할 수 없을 때 

⇒ 즉, 둘 이상의 프로세스들이 서로 충돌되는 자원 요구를 할 때 발생!


### 결합 진행 다이어그램

프로세스 P,Q가 자원 A,B 사용에 대해 경쟁하며 수행하는 과정

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/25fababd-c9e0-4472-8bb8-9a708dcb90fe)

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/3140502d-f89a-452a-94a8-b4d80c658037)

- 빗금 표시된 부분은 두 프로세스가 모두 A 혹은 B를 필요로 하고 있기 때문에 실제로 진입할 수 없는 영역

  
- **교착 상태 발생 예시**
    1. 프로세스 P가 자원 A를 얻음
    2. 프로세스 Q가 자원 B를 얻음
    3. P는 이후 B를 필요로 하지만 B는 Q가 가지고 있으므로 블록됨
    4. Q도 A를 얻지 못해 블록됨
    
    ⇒ 교착상태 발생!
    
- 1, 2번까지 진행이 된다면 이미 교착상태를 피할 수 없는 상태
    
    ⇒ **치명적인 영역** (위 그림에서의 회색 영역)


- **교착상태가 발생하지 않는 예시**
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/a6fa016c-7471-4b91-9183-f411966f3986)

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/ec8051f5-5b7f-4f81-b0cd-963f231129ab)
  - 프로세스 P는 A와 B를 사용한 후 바로 해제해주고 있다

    
  ## 프로세스가 사용하는 자원의 종류
  
  1. 재사용 가능한 자원
  2. 소모성 자원
  
  ### 재사용 가능한 자원
  
  - 프로세스의 사용에 의해 없어지지 않는 자원
  - 한 프로세스가 사용한 후 재사용을 위해 반납해야 함
  - ex) 처리기, 주/보조 메모리, 커널 자료구조(파일, 데이터베이스, 세마포어 등)
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/4f159976-25ce-4a5f-b84b-955a36ae9b1c)
    - 
  ### 소모성 자원
  
  - 생성되었다가 사용된 이후 소멸되는 자원
  - ex) 인터럽트, 시그널, 메시지, I/O 버퍼에 존재하는 정보 등
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/91349833-53a7-4190-8e6e-238922521119)


### 자원 할당 그래프

- 방향이 존재하는 유향 그래프
- **자원** : 사각형
- **프로세스** : 원
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/ae654a2a-7c3a-4aac-8601-73bab0ada1d6)

  - 자원 내부의 점은 사용 가능한 자원의 개수를 의미
  - 자원의 점에서 프로세스로 향하는 링크
      - 재사용 가능한 자원 : 프로세스가 자원을 할당받은 상황
      - 소모성 자원 : 해당 프로세스가 자원의 생산자인 상황


### 교착상태 조건 (필요충분조건)

1. **상호배제** : 한 순간에 한 프로세스만이 자원을 사용할 수 있다.
2. **점유대기** : 이미 자원을 보유한 프로세스가 다른 자원을 요청하며 기다리고 있다. 
3. **비선점** : 프로세스가 점유한 자원을 다른 프로세스가 강제로 뺏을 수 없다. 
4. **환형대기** : 자원 할당 그래프에서 환형이 만들어진 상태

- 4가지 조건 중 일부만 충족 → 교착상태가 가능한 상태
    - 1, 2, 3번 조건은 OS에서 대부분 이루어지고 있는 정책
    - 즉 4번 환형대기 조건의 성립 여부가 중요!
    
- 4가지 모두 만족 → 교착 상태 발생한 상태


### 교착상태 해결을 위한 접근 방법

- **예방**
- **회피**
- **발견**
    - 아래로 갈 수록 더 느슨한 해결 방법


      
## 교착상태 예방
운영체제 설계 시 교착상태가 발생할 가능성을 없애는 방식

⇒ 4가지 필요충분조건 중 하나를 설계 단계에서 배제 

- 간접적인 방법 : 1~3번 조건 중 하나를 비허용
- 직접적인 방법 : 4번 환형대기 조건을 비허용

### 상호배제

- 공유자원의 일관성 유지를 위해 꼭 필요한 조건이므로 없앨 수 없다.

### 점유대기

1. 프로세스가 자신이 필요한 모든 자원을 한 번에 요청
2. a. 모든 자원을 할당받을 수 있다면 계속 수행
    
    b. 하나라도 할당받을 수 없다면 대기
    
     
    
- **문제점**
    - 모든 자원을 할당받을 수 있을 때까지 대기 시간이 오래 걸릴 수 있다.
    - 수행의 끝부분에 사용되는 자원은 오랜 시간동안 사용되지 않지만, 점유되어 있다.
        
        ⇒ 다른 프로세스가 해당 자원을 사용할 수 없으므로 비효율적
        
    - 프로세스가 미래에 사용될 자원을 미리 알기 어렵다.

### 비선점

- **방법 1**
    1. 자원을 점유한 프로세스가 다른 자원 요청 
    2. 자원 할당 불가능한 경우, 자신이 점유한 자원 반납
    3. 프로세스는 원래 자원과 새로 원하는 자원을 함께 요청 
    
- **방법 2**
    1. 프로세스가 점유하고 있는 자원을 다른 프로세스가 요청
    2. 운영체제는 요청된 자원을 강제 반납시켜 요청한 프로세스에 할당
    
    ⇒ 프로세스에 우선순위가 있을 때 교착상태 예방 가능!
    

### 환형대기

- 자원들의 할당 순서를 정한다.
- 할당 순서에 의해, 프로세스는 자신이 점유한 자원의 다음 순서에 해당하는 자원만을 요청할 수 있다.

- **문제점**
    - 프로세스 수행 지연
    - 불필요한 자원 할당 거부
    


## 교착상태 회피

- 1~3번 조건은 허용. 4번 조건을 위해 자원 할당 순서 정하지 않음
- 환형 대기 방지를 위해 자원 할당 시 교착상태가 발생 가능한 상황이 되지 않도록 고려한 후 할당
    
    ⇒ 자원 사용의 효율성이 높아 예방에 비해 더 많은 병행성 제공 
    
- 이 할당이 교착상태를 발생시킬 가능성이 있는지 동적으로 조사
- 현재 자원의 가용 개수, 프로세스의 자원 요구량을 미리 알아야 사용할 수 있는 방법!

### 회피 기법 1 : 프로세스 시작 거부

프로세스가 시작하려 할 때 요구하는 자원 할당이 교착상태를 발생시킬 가능성이 있다면, 프로세스의 시작을 거부하는 기법 

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/ab08dded-fc8d-424a-9699-3be7c34d51fd)

  - C는 프로세스가 요구하고 있는 자원의 개수
  - A는 프로세스에 할당되어 있는 자원의 개수
  - 운영체제는 프로세스 수행 전에 위 정보를 모두 알고 있어야 함

- 모든 프로세스가 요구한 자원의 개수가 전체 자원의 개수보다 적으면 교착상태가 발생하지 않음!
  
### 회피 기법 2 : 자원 할당 거부

수행 중인 프로세스가 요구하는 추가적 자원 할당이 교착상태를 발생시킬 가능성이 있다면, 자원 할당을 거부하는 기법
- **안전한 상태** : 교착상태가 발생하지 않도록 프로세스에게 자원을 할당할 수 있는 진행 경로가 존재하는 경우 ⇒ 수행을 완료할 수 있는 프로세스가 존재하는가?
- **불안전한 상태** : 이러한 진행경로가 존재하지 않는 경우
    
  ### 은행원 알고리즘 (banker’s algorithm)
  - C-A : 프로세스가 현재 필요로 하는 자원의 수
  - R-A ⇒ V
  - **안전한 상태 예시**
    
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/a2d708fe-b672-4246-abc6-e70145093566)

  - 가용 벡터 V에 C-A보다 더 많은 값이 들어있으면 해당 프로세스는 수행 가능
    - (a) 현재 프로세스 2는 R3 자원을 1개 요청하고 있는데, 가용벡터에 R3이 하나 존재하므로 수행 가능.
    - (b) 프로세스 2가 수행이 완료되면서 자신이 가지고 있던 자원을 모두 반납. 이제 프로세스 1, 3, 4이 모두 수행 가능한 상태
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/01f8a4d7-6736-41de-8826-baf16991d2e9)

    - 순서대로 P2, P1, P3, P4가 수행 가능한 상태이므로 **안전한 상태**
    - 안전한 상태를 유지하는 진행 경로는 여러 개일 수 있다.

 - **불안전한 상태 예시**
   
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/3a1c5d25-4a78-4990-b870-c1c78a9adbd3)

    - (a) →(b) 다음과 같은 할당은 불안전한 상태를 야기하고, 자원 할당 거부 방법은 이러한 상황을 허용하지 않는다.
    - (b)의 상태가 반드시 교착상태를 발생시키는 것은 X
      ⇒ 교착상태가 발생할 수 있는 가능성이 큰 상태 O 
    

  ### 교착상태 회피 알고리즘
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/04a2a2ad-c72b-44ad-91a2-3add9f2f3699)
  
  - request[*] : 현재 프로세스 i에 의해 요청된 자원 
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/5a7d9d16-edd0-44b0-9973-1251ef2553db)

### 교착상태 회피의 단점

- 각 프로세스가 사용할 최대 자원 요구량을 운영체제가 미리 알고 있어야 함
- 프로세스 간 수행 순서 종속 관계가 없고 각 프로세스가 독립적이어야 함
- 자원 개수가 고정되어야 함 (추가 자원 요청이 없어야 함)
- 자원을 선점한 채로 프로세스가 종료되어서는 안됨



## 교착상태 발견

- 자원 할당이 가능한 상태라면 항상 할당해줌
- 주기적으로 시스템에 환형대기 조건이 발생했는지 검사하고, 발생 시 해결

### 교착상태 발견 알고리즘

- 자원 할당 요구될 때마다 수행될 수도, 주기적으로 가끔씩 수행될 수도 있음
- 기존 행렬, 벡터 + 새로운 **요청 행렬** 사용
    - 요청 행렬 : 프로세스에 의해 요청된 자원의 개수

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/6c9af196-ec5f-44b2-8e76-5a8fc652288c)

1. 할당 행렬 A에서 행의 값이 모두 0인 프로세스 우선 표시 (P4)
2. 임시 벡터 W 생성하고 가용벡터 V의 값을 W의 초기값으로 설정
3. 나머지 프로세스 중 요청 행렬 Q의 값이 모두 W보다 작은 프로세스를 표시 (P3)
    
    → 만약 작은 프로세스가 없다면 알고리즘 종료 
    
4. 해당 프로세스가 수행 완료되었다고 가정해, 프로세스에게 할당된 자원을 W에 더해줌
    
    즉, W = (0, 0, 0, 1, 1)
    
5. 3번 과정을 다시 수행 

⇒ 이 알고리즘이 종료된 이후 표시되지 않은 프로세스가 있다면, 교착상태 발생한 것 

- 위의 예시에서는 P3가 표시된 후 알고리즘이 종료되고 P1,P2는 표시되지 않음
- P1, P2는 교착상태

### 교착상태 회복 알고리즘

- 교착상태 발견 후 해결을 위한 방법
1. 교착상태에 포함된 모든 프로세스 중지
2. 교착상태에 포함된 각 프로세스 수행을 롤백. 하지만 다시 수행해도 교착상태에 빠질 수 있음
3. 교착상태가 없어질 때까지 교착상태에 포함된 프로세스들을 하나씩 종료.
4. 교착상태가 없어질 때까지 교착상태에 포함된 자원을 하나씩 선점. 
    - 종료 또는 선점될 프로세스/자원 선택 기준
        - 지금까지 사용한 처리기 시간이 적은 프로세스부터
        - 지금까지 출력량이 적은 프로세스부터
        - 남은 수행 시간이 가장 긴 프로세스부터
        - 할당받은 자원이 적은 프로세스부터
        - 우선 순위가 낮은 프로세스부터
        
- 아래로 갈 수록 복잡도 증가
- 각 방법을 수행한 후 교착상태 발견 알고리즘을 재수행해 교착상태 여부를 재확인



## 교착상태에 대한 통합적 전략

- 시스템의 조건에 따라 다른 전략을 쓰는 것이 효율적
    1. 자원들을 유형에 따라 서로 다른 클래스로 구분
    2. 자원 클래스 간 할당 순서를 두어 환형대기 예방
    3. 클래스 내부 자원 간에는 적절한 교착상태 해결 방법을 사용

1. **자원 클래스**
    - 스왑 공간 : 보조 디스크 상 메모리 블록
    - 프로세스 자원 : 파일, 테이프 드라이브 등 할당 가능한 장치 자원
    - 주 메모리 : 프로세스들에게 할당되는 자원 (단위 : 페이지, 세그먼트 등)
    - 내부 자원 : ex) 입출력 채널

1. **할당 순서** 
    - 스왑 공간 → 프로세스 자원 → 주 메모리 → 내부 자원

1. **적절한 해결 방법**
    - 스왑 공간 : 교착상태 예방 전략 -
    - 프로세스 자원 : 교착상태 회피 전략 -
    - 주 메모리 : 교착상태 예방 전략 - 선점을 허용
    - 내부 자원 : 교착상태 예방 전략 - 자원 할당 순서를 미리 결정



## 식사하는 철학자 문제

- 5명의 철학자가 원형 테이블에 앉아있다.
- 사용할 수 있는 포크가 5개 있고, 각 포크는 한 명만 사용 가능하다. (임계영역)
- 어떤 철학자도 식사를 하지 못하면 안된다.
- 철학자는 식사를 위해 2개의 포크를 사용한다.


### 세마포어를 이용한 해결방법

- **첫 번째 방법**
  
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/885246bd-bbdc-4bde-8d09-e6e11eaa1937)

- wait (fork[i]) : 철학자는 왼쪽 포크를 먼저 집는다.
- wait (fork[i + 1] mod 5) : 바로 오른쪽 포크를 집는다.
- signal(fork[i + 1] mod 5) : 먹는 과정을 마친 후 오른쪽 포크를 내려놓는다.
- signal(fork[i]) : 왼쪽 포크를 내려놓는다.
    - 만약, 모든 철학자들이 동시에 식탁에 앉아 왼쪽 포크를 동시에 집었다면?
        - 모든 철학자의 오른쪽 포크가 존재하지 않으므로 교착상태에 빠짐

- **두 번째 방법 → 1번 보완**
  
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/bfe5321a-65cd-45a5-9a25-9c5eac7786dc)

  - room = {4} : 최대 4명의 철학자만 식탁에 앉을 수 있다.
  - 만약 철학자가 모두 동시에 왼쪽 포크를 잡더라도, 한 명의 철학자는 오른쪽 포크가 남아있어 식사를 마칠 수 있다.

  

### 모니터를 이용한 해결방법

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/b94e42ab-9118-44f7-bcc2-faa7936bce7a)

  - fork 벡터 값이 참이면 사용 가능, 거짓이면 사용 불가능
  - **get_forks()**
      - 2개의 포크를 요청
      - 둘 중 하나라도 사용할 수 없는 상태라면 해당하는 조건변수에서 대기(cwait)
  - **release_forks()**
      - 2개의 포크를 반납
      - 반납할 때 포크를 받으려고 대기하는 프로세스가 있다면 csignal로 깨움
  
  - 모니터에는 하나의 프로세스만 진입할 수 있으므로, 교착상태 발생 X
      - 한 철학자가 모니터에 진입해 왼쪽 포크를 집은 후, 오른쪽 포크를 집는 것이 보장됨
      - 오른쪽 철학자가 그 사이에 자신의 왼쪽 포크를 집을 수 없음
