# 7장 메모리 관리

### 메모리 관리 관련 용어

- 프레임 : 주기억장치의 고정 길이 블록
- 페이지 : 보조기억장치의 고정 길이 블록
- 세그먼트 : 보조기억장치의 가변 길이 블록

## 메모리 관리 요구조건

- 재배치
- 보호
- 공유
- 논리적 구성
- 물리적 구성

### 재배치

- 프로그램이 디스크로 스왑아웃된 후, 다시 주기억장치로 스왑인될 때 이전과 동일한 위치가 아닌 다른 위치로 재배치될 수 있다.
- 재배치를 고려해 프로세스 주소를 지정해야 한다.
- 처리기 하드웨어와 운영체제 소프트웨어는 프로그램 코드의 메모리 참조 부분을 실제 물리 주소로 변환할 수 있어야 한다.

### 보호

- 다른 프로세스들의 간섭으로부터 보호
    - 메모리 참조 검사 : 참조된 메모리가 해당 프로세스 영역 내에 해당하는지 확인
    - 메모리 보호 → 처리기(하드웨어)적인 검사 요구

### 공유

- 여러 프로세스가 주기억장치의 동일한 부분에 접근하려고 할 때, 융통성있게 허용
- 데이터 보호를 위해 제한된 접근을 통한 공유

### 논리적인 구성

- 일반적으로 프로그램을 모듈단위로 구성
- 운영체제와 하드웨어가 모듈을 효과적으로 처리할
- 대표적인 기술 : 세그먼테이션

### 물리적인 구성

- 컴퓨터 메모리는 주기억장치, 보조기억장치로 구성
- 이 두 계층 사이의 정보 흐름을 어떻게 구성하는지가 매우 중요
    - 이러한 흐름 구성은 프로그래머 개인이 아닌 시스템이 책임짐

## 메모리 분할

- **연속 메모리 관리**
    - 프로그램 전체가 메모리 공간에 연속적으로 할당되어야 함
        - **단일 연속 메모리 관리**
        - **고정 분할 기법**
        - **동적 분할 기법**
        
- **불연속 메모리 관리**
    - 프로그램이 부분들로 쪼개져 서로 다른 주소 공간에 할당될 수 있음
        - **고정 크기 : 페이징**
        - **가변 크기 : 세그먼테이션**

## 고정 분할 기법

주기억장치를 고정된 크기로 분할한다. 

1. **균등 분할** : 주기억장치를 모두 같은 크기의 파티션으로 나눈다.
2. **비균등 분할** : 주기억장치를 여러 크기의 파티션으로 나눈다. 

### 배치 알고리즘

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/d5ae37eb-33d6-4c6a-94a2-7fe18bfd6290)

- **균등 분할**
    - 사용 가능한 파티션이 있다면 바로 적재
    - 파티션이 없다면 기존 프로세스 중 하나를 스왑 아웃한 후 적재
- **비균등 분할**
    - 프로세스의 크기에 따라 내부 단편화를 최소화할 수 있는 최적 파티션에 적재
    - 각 파티션마다 하나의 프로세스 큐 사용 vs **단일 큐 사용**
        - 파티션마다 프로세스 큐
            - 프로세스의 크기에 따라 최적의 파티션 큐에서 대기함
                
                ⇒ 남는 파티션이 있는데도 할당되지 않는 문제점 발생!
                

### 단점

- 파티션의 크기보다 큰 프로그램을 실행할 때는 오버레이 기법을 이용해야 함
- 파티션의 크기보다 작은 프로그램이 적재된 경우, 나머지 공간이 낭비되는 내부단편화 발생
- 파티션의 수에 의해 활성화될 수 있는 프로세스의 수가 제한됨

## 동적 분할 기법

- 파티션의 크기와 개수가 가변적
- 프로세스가 요구하는 크기만큼만 메모리를 할당해주므로 내부 단편화 X
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/b0bf99ad-02f4-48be-be58-b8363af90d93)

    
- But, 할당된 파티션 사이사이 작은 메모리 공간 여러 개가 낭비되는 **외부 단편화** 발생
- 외부 단편화로 만들어진 작은 공간을 합쳐주는 **메모리 집약** 과정이 필요

### 배치 알고리즘

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/7d7df4ae-a55b-49e5-9b34-5ba120e2ed63)

- **최적적합**
    - 메모리를 탐색하며 남는 공간 중 가장 외부단편화를 적게 발생시키는 곳에 적재
- **최초적합**
    - 메모리를 탐색하면서 들어갈 수 있는 공간을 발견하면 바로 적재
- **순환적합**
    - 가장 마지막으로 참조된 파티션부터 메모리를 탐색하며 들어갈 수 있는 공간에 바로 적재 ⇒ 메모리 공간의 끝부분에 쏠린 적재
- **최악적합**
    - 외부단편화를 가장 크게 발생시키는 곳에 적재

## Plus. 버디 시스템

- 고정 분할과 동적 분할의 단점을 보완한 절충안

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/b5117771-2ae6-4d24-b909-7b6c26a29960)

- 프로세스에 할당 가능한 공간은 2의 제곱수 크기로 정해짐
- 요청이 들어왔을 때 내부단편화가 가장 적게 발생하는 크기가 될때까지 기존 공간을 절반으로 자른다.
- E가 반환될 때, 사용하지 않는 공간들이 다시 합쳐진다.

## 재배치

- 프로세스는 생존 기간동안 다른 파티션에 적재될 수 있다.
- 이러한 재배치를 용이하게 하기 위해 논리주소가 사용된다.
    - **논리주소** : 물리주소와는 독립적인 메모리 위치
    - **상대주소** : 논리주소의 한 예. 한 절대 위치로부터 얼마나 떨어져 있는지를 나타냄
    - **물리주소** : 데이터가 저장되어 있는 실제 메모리의 위치
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/13237374-3101-47f5-ac52-41b0553f55fe)

    
- 프로그램의 시작 위치를 저장해두는 베이스 레지스터
- 프로그램의 종료 위치를 저장해두는 경계 레지스터
- 상대주소를 받으면 베이스 레지스터 내의 값을 이용해 절대주소로 변환
- 변환된 절대주소가 해당 프로세스의 영역 내에 있는지 비교기를 이용해 점검

## 페이징

- 주메모리 공간을 프레임이라는 아주 작은 단위로 나눈다.
- 프로세스를 페이지라는 아주 작은 단위로 나눈다.
- 프레임과 페이지의 크기는 동일하고, 주메모리에 빈 프레임이 생기면 페이지 단위로 프로세스가 할당될 수 있다.
- 고정 분할 방식과 유사
    
    ### 고정 분할과 페이징
    
    - **공통점**
        - 고정 크기로 주메모리 영역을 나누어서 프로세스를 할당한다.
        
    - **페이징만이 가지는 특징**
        - 나누는 고정 크기가 훨씬 작다.
        - 한 프로그램이 하나 이상의 파티션을 차지할 수 있다.
        - 한 프로그램이 차지하는 파티션이 불연속적일 수 있다.
        
- 프로세스가 메모리 공간에 불연속적으로 할당되어도 괜찮다!
    - 이를 위해서는 베이스 레지스터만으로는 부족..
    - 각 프로세스마다 페이지 테이블이 필요하다!
- 외부단편화 X, 프로세스의 마지막 페이지에서만 내부 단편화가 발생

### 페이지 테이블

- 프로세스 각 페이지에 해당하는 프레임의 위치를 관리
- 각 페이지마다 하나의 항을 가지고, 만약 페이지가 주메모리에 할당된 경우 해당 프레임 번호가 저장되어 있다.
- 논리주소가 주어지면 처리기는 페이지 테이블을 이용해 물리주소를 생성 (HW적)
    - **논리주소** : 페이지 번호 + 페이지 내의 오프셋
    - **물리주소** : 프레임 숫자 + 오프셋

### 논리 - 물리 주소 변환 방식

If, 페이지 크기 = 1K(2^10), 16비트 주소 체계 시스템

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/cc179b77-ca2e-4382-b1ca-0f1d77b54e35)


- 오프셋을 표현하는데 10비트 필요
- 따라서 나머지 6비트로 페이지 번호 표현 가능 ⇒ 페이지의 최대 개수 = 2^6개
- 상대주소 1502 = 1(페이지 번호) * 1024(페이지 크기) + 478(오프셋)
- 물리주소 ⇒ 프레임 번호 * 1024 + 오프셋

[[OS] 페이징 & 세그먼테이션](https://dar0m.tistory.com/269)

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/89432c58-abae-4949-91ef-39ba1ae3dda5)


- 페이지 번호를 페이지 테이블의 인덱스로 사용해 항목을 찾고, 페이지 테이블에 저장되어 있는 물리 프레임 번호와 논리주소의 오프셋을 더해 물리주소로 변환!

## 세그먼테이션

- 가변적인 크기의 세그먼트 이용
- 세그먼트는 논리적 단위로, 미리 분할되지 않고 메모리를 사용하는 시점에 할당됨
- ex) 프로세스를 코드/데이터/스택 영역으로 나누는 것
- 동적 분할 방식과 유사
    - 차이점 : 한 프로그램이 차지하는 파티션이 비연속적
- 내부단편화 X, 외부단편화는 최소화함
- 페이지와 마찬가지로 불연속적인 메모리 할당이 가능하고, **세그먼트 테이블** 필요!
    - 세그먼트 테이블에는 세그먼트 길이 값이 추가적으로 저장됨
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/ab51a407-822e-41bf-ac03-c5bbc743fe9e)

    - 길이 값을 이용해 주소가 해당 세그먼트 영역 내에 위치하는지 확인
    - 만약 영역을 벗어난다면 인터럽트 발생해 해당 프로세스 강제 종료
    
- 공유와 보호가 효율적
