# 3장 프로세스 기술 및 제어

- **운영체제가 만족해야 하는 대부분의 요구조건**은 프로세스와 관련지어 설명됨
  
    1. 운영체제는 cpu 이용률 극대화를 위해 여러 프로세스 수행을 인터리빙해야 한다. 
        - **인터리빙** : 교행 수행. 여러 프로세스가 번갈아가며 수행되는 것으로 병렬 처리가 아닌 직렬 처리이다. 하지만 번갈아 수행되는 시간 간격이 매우 짧아 동시에 수행되는 것처럼 느껴진다.
          
    2. 운영체제는 교착상태를 회피함과 동시에 우선순위 같은 정책에 부합하도록 자원을 프로세스에 할당해야 한다.
    3. 운영체제는 프로세스 간 통신(**IPC**)과 사용자의 프로세스 생성을 지원해야 한다. 

## 배경지식

- 컴퓨터 플랫폼은 처리기, 주기억장치, 입출력 모듈 등과 같은 하드웨어 자원의 집합으로 구성된다.
- 컴퓨터 응용은 전형적으로 외부로부터 입력을 받아들여 처리한 후 출력한다.
- 하드웨어 플랫폼 상에 직접 응용을 작성하는 것은 비효율적이다.
- 운영체제는 응용들에게 편리한 기능, 인터페이스를 제공하기 위해 개발되었다.
- 운영체제는 응용들이 사용하는 자원에 대한 추상적 표현을 제공하고, 자원의 공유나 보호를 지원할 수 있다.

### 응용 수행 시 운영체제가 하는 일

- 여러 응용들이 자원을 이용할 수 있게 함
- 여러 응용 사이에 CPU를 교체 할당해, 모든 응용이 병행 진행되는 것처럼 보이게 함
- CPU와 입출력 장치들이 효율적으로 사용되게 함

## 3.1 프로세스란?

- 수행중인 프로그램
- 처리기에 할당되어 수행될 수 있는 개체
- 컴퓨터 상에 수행중인 프로그램의 인스턴스
- 현재 상태, 명령들의 순차 수행 등에 의해 특징지어지는 활성화 단위
    
    ⇒ 동일한 프로그램을 수행하는 프로세스들이 여러 개 존재할 수 있다. 
    

### 프로세스의 필수적인 요소

- **프로그램 코드**
- **데이터의 집합**

### 프로세스 식별 요소

- **식별자**
- **상태** : ex) 프로세스가 현재 수행 중이라면, **수행** 상태에 해당된다.
- **우선순위**
- **프로그램 카운터(PC)** : 다음에 수행될 명령어의 주소
- **메모리 포인터** : 프로세스와 연계되는 코드 및 데이터, 공유되는 메모리 블록의 포인터
- **문맥 데이터** : 프로세스 수행 중에 CPU 레지스터에 존재하는 데이터
- **입출력 상태 정보**
- **어카운팅 정보** : 과금 정보

⇒ 위 요소들을 통해 프로그램 수행 중 특정 시점에 프로세스 식별이 가능하며, 
    **프로세스 제어 블록(PCB)**이라는 자료구조에 저장된다.

### 프로세스 제어 블록

- 운영체제가 생성하고 관리한다.
- 수행 중에 프로세스가 인터럽트되었을 때, 이후 문제없이 수행이 재개될 수 있도록 인터럽트 당시 프로세스의 정보를 유지하는 역할
- ex) 블록 상태였던 프로세스가 수행 상태로 변경되면, 제어 블록에 저장되어 있는 프로세스의 PC값과 문맥 데이터를 CPU 레지스터로 적재해 수행을 시작할 수 있다.

## 3.2 프로세스 상태

- CPU는 PC 값에 의해 결정된 순서에 따라 명령어를 수행
- PC에 다른 프로그램 내의 코드 주소가 적재되면 다른 프로그램으로 교체될 수 있음
  
### 프로세스의 궤적

프로세스는 일련의 명령어 리스트로 표현될 수 있음 ⇒ 프로세스의 **궤적**

- 디스패처 : 다른 프로세스로 교체해주는 프로그램
- 프로세스 A,B,C는 주기억장치에 완전히 적재되어 있는 상태
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/213f6c9d-f75c-4250-8461-0b958d72626d)
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/d4657540-c00e-4eff-bd83-c4b92af81fac)
  
  - 프로세스 B에서는 8003 주소의 명령어가 입출력 연산 요청
    
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/c55b2c17-cd74-4643-aad9-302f7154afa0)
  
  - 100 ~ 105는 디스패처 프로세스 수행 (디스패처 시작 주소  = 100)
  - 한 프로세스는 최대 6개의 명령어까지만 연속 수행될 수 있음 → 독점 방지
    1. **프로세스 A 명령어 6개 수행**
    2. **인터럽트되어 디스패처 프로세스 수행 후 B로 제어 이동**
    3. **프로세스 B 명령어 수행 중 입출력 요청**
    4. **인터럽트되어 디스패처 프로세스 수행 후 C로 제어 이동**
    5. **프로세스 C 명령어 6개 수행**
    6. **아직 B는 입출력 연산이 완료되지 않은 상태이므로 이후 프로세스 A가 수행됨**
       
### 2-상태 프로세스 모델

이 모델에서, 프로세스는 아래 두 상태 중 한 상태에 있게 된다.  

- **수행 (Running)**
- **비수행 (Not Running)**
- 새로운 프로세스가 생성될 때, 운영체제는 프로세스 제어블록을 생성하고 비수행 상태로 초기화 ⇒ 운영체제에게 프로세스의 존재가 인식됨
    
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/4dd1e985-caf9-482a-aa4e-4b9ca1d42a0a)

- 디스패처에게 선택되어 수행되는 프로세스는 수행 상태로 전이
- 인터럽트 당한 프로세스는 비수행 상태로 전이
- 수행되지 않는 프로세스들은 수행을 기다리며 일종의 큐에 저장
- 큐에는 각 프로세스의 제어블록을 가리키는 포인터가 저장됨
- 디스패처는 큐에서 다음 수행할 프로세스를 선택

### 프로세스의 생성

**운영체제는 어떤 프로세스의 명시적인 요청에 의해 새로운 프로세스를 생성할 수 있다.**

(어떤 프로세스 → 부모 프로세스, 새로운 프로세스 → 자식 프로세스)

1. 새로운 일괄처리 작업 (일괄처리 환경에서)
2. 새로운 사용자의 로그온 (대화식 환경에서)
3. 서비스 제공을 위해 운영체제가 생성 : 사용자
4. 기존 프로세스에 의한 생성
- 새로운 프로세스를 추가할 때, 운영체제는 프로세스 관리를 위해 필요한 자료구조를 만들고, 프로세스에 주기억장치 내 주소 공간을 할당

### 프로세스의 종료
- **종료되는 이유**
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/2f2d6232-54c1-4ffe-bfbe-71d9759364b2)

### 5-상태 프로세스 모델

수행되지 않는 프로세스 중 당장 수행이 가능한 프로세스도 있지만, 입출력 연산 완료를 기다리는 블록된 프로세스도 존재한다. 

⇒ 단일 큐에서는 큐에서 가장 오래 머문 블록되지 않은 프로세스를 찾아야 한다.

⇒ 비수행 상태를 준비 상태와 블록 상태로 분할하자!

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/ba3726a4-7175-46c6-9193-f095c57df0e2)

- **수행**
- **준비** : 제어가 넘어오면 바로 수행이 가능한 프로세스
- **블록(대기)** : 어떤 이벤트가 발생할 때까지 수행될 수 없는 프로세스
- **생성** : 운영체제에 의해 수행가능 프로세스 풀로 진입이 아직 허용되지 않은 프로세스
    - 프로세스 제어 블록은 주기억장치에 있지만 프로그램 코드, 데이터 공간은 할당되지 않은 상황
- **종료 :** 운영체제에 의해 수행가능 프로세스 풀에서 방출된 프로세스
    - 더 이상 수행은 불가능하지만 관련된 테이블, 정보들은 운영체제에 의해 잠시 보존

### 프로세스 상태 전이

- **null → 생성** : 프로그램 수행을 위해 프로세스 생성
- **생성 → 준비** : 대부분 시스템에는 프로세스 수 제한이 있거나, 프로세스에 할당되는 가상메모리 양 제한이 있다. 이러한 문제가 없을 때, 운영체제는 생성된 프로세스를 받아들일 준비가 된다.
- **준비 → 수행** : 스케줄러 또는 디스패처가 준비 프로세서 중 하나를 선택
- **수행 → 종료** : 수행 중인 프로세스의 작업이 완료되거나 수행이 중단
- **수행 → 준비** : 일반적으로 프로세스에 할당된 처리기 시간을 모두 사용했을 때에 준비 상태로 전이된다. 또, 현재 수행중인 프로세스 A보다 높은 우선순위의 프로세스 B가 있는 경우에 A가 준비 상태로 전이될 수 있다. (운영체제가 A를 **선점**한 경우)
- **수행 → 블록** : 프로세스가 요구한 자원을 기다려야 할 때, 다른 프로세스로부터 메시지를 기다릴 때 등 이벤트를 기다리고 있는 상황에서 블록 상태로 전이된다.
- **블록 → 준비** : 블록 상태인 프로세스가 기다리던 이벤트가 발생한 경우
- **준비 → 종료** : ex) 부모 프로세스에 의해 자식 프로세스가 종료된 경우
- **블록 → 종료** : 위와 동일

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/6da71ac5-40de-40b6-acc9-c668d84854af)
(a) 준비큐와 블록큐를 사용. 디스패처는 준비큐에 있는 프로세서 중 하나를 선택해 제어를 넘긴다. 블록큐에 있는 프로세스 중 기다리던 이벤트가 발생한 프로세스는 준비큐로 옮겨진다. 

(b) 준비큐와 블록큐 여러 개를 사용. 이벤트가 발생했을 때 블록큐를 전체적으로 조사해 해당 이벤트를 기다리던 프로세스를 찾아야 한다. 각 이벤트마다 하나의 블록큐를 두어 이벤트 발생 시 해당 블록큐 내의 모든 프로세스를 준비 상태로 전이시키는 것이 효과적일 수 있다. 

### 보류된 프로세스

가상메모리를 사용하지 않는 시스템으로 가정 ⇒ 수행될 프로세스는 주기억장치에 완전히 적재되어야 함

- 멀티 프로그래밍 환경이더라도, 처리기의 속도가 입출력 장치의 속도보다 훨씬 빠르기 때문에 결국 메모리에 있는 모든 프로세스들은 입출력 완료를 기다리게 될 것..
- 즉, 처리기가 유휴 상태인 시간이 대부분
    
    ⇒ **스와핑** 기법으로 해결!
    
    ### 스와핑
    
    프로세스의 일부 혹은 전체를 주기억장치로부터 디스크로 옮겨 놓는 방법
    
    - 주기억장치의 프로세스 중 준비 상태인 프로세스가 없다면, 블록 상태인 프로세스 중 하나를 디스크로 보내고 **보류큐**에 넣음 ⇒ ‘**보류’** 상태 추가
    - 주기억장치의 블록 상태 프로세스 중 하나를 **보류 상태**로 전이하고 디스크로 전송
    - 주기억장치와 디스크로 프로세스가 왔다갔다 할 수 있음
    - 주기억장치의 빈 공간에 다른 프로세스를 불러올 수 있음
        - 새로 생성된 프로세스
        - 이전에 보류되었던 프로세스 → 시스템 부하를 증가시키지 않음
    - 블록 상태에 있던 프로세스가 보류되므로, 주기억장치로 복귀할 때 여전히 블록 상태에 있어 수행이 안될 가능성이 있음. ⇒ 다음 두 가지 상태 도입
        - **블록/보류** : 프로세스가 보조기억장치에 있고, 이벤트를 기다리는 중
        - **준비/보류** : 보조기억장치에 있지만, 주기억장치에서는 즉시 수행 가능
    
    ### 새로운 프로세스 상태 전이
    
    - **블록 → 블록/보류** : 준비 상태의 프로세스가 있어도 발생할 수 있다. (프로세스가 적절한 성능 유지를 위해 더 많은 주기억장치 공간을 요구하는 경우)
    - **블록/보류 → 준비/보류** : 기다리던 이벤트가 발생한 경우
    - **준비/보류 → 준비** : 주기억장치에 준비된 프로세스가 없는 경우. 준비/보류 프로세스가 더 높은 우선순위를 가진 경우도 가능
    - **준비 → 준비/보류** : 주기억장치에 공간을 만들 수 있는 유일한 방법인 경우
    - **생성 → 준비/보류** : 생성 후 프로세스에게 주소공간을 할당할 때 주기억장치에 공간이 마땅치 않은 경우
    - **블록/보류 → 블록** : 우선순위가 높은 블록/보류 프로세스가 기다리는 이벤트가 곧 발생할 것이라고 판단한 경우
    - **수행 → 준비/보류** : 블록/보류 큐에 있던 우선순위가 높은 프로세스가 블록이 해제되어 수행 중인 프로세스를 선점했다면, 선점된 프로세스를 준비/보류 큐로 이동
    
- **보류상태의 프로세스**
    1. 즉시 수행될 수 없다.
    2. 이벤트를 기다리고 있을 수도(블록/보류), 기다리지 않을 수도(준비/보류) 있다.
    3. 어떤 에이전트가 프로세스 수행을 막기 위해 그 상태를 보류 상태로 바꿨다.
    4. 에이전트가 명시적으로 해제 명령을 내릴 때까지 보류 상태에서 벗어날 수 없다. 
    
- **보류 발생 이유**
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/46a5cfd4-e652-43b8-88c8-548e17372bad)

## 3.3 프로세스 기술
운영체제가 프로세스를 제어하고, 자원을 관리하기 위해 필요한 정보는 무엇인가?

### 운영체제 제어 구조

운영체제는 프로세스, 자원들을 관리하기 위해 각 개체에 대한 정보를 **테이블로 구성해 유지**한다. 

- **메모리 테이블**
    
    주기억장치의 일부는 운영체제에게 할당이 고정되어 있다.
    
    - 프로세스에게 할당된 주기억장치 공간
    - 프로세스에게 할당된 보조기억장치 공간
    - 주기억장치/가상메모리 블록들에 대한 속성
    - 가상메모리 관리를 위해 필요한 정보
    
- **입출력 테이블**
    - 입출력 동작의 진행 상태
    - 입출력 전송의 출발지, 목적지 (주기억장치 내의 위치)
    
- **파일 테이블**
    - 파일의 존재 여부
    - 보조기억장치에 저장된 파일의 위치, 현재 상태 등
    
- **프로세스 테이블**

⇒ 위 4개의 테이블은 서로 연결되거나 상호 참조되어야 한다. 

### 프로세스 제어 구조

운영체제는 프로세스의 위치와 상태, ID 등의 속성들을 알아야 한다 .

- **프로세스 위치**
    - 프로세스 : 수행될 프로그램 + 관련된 데이터 위치 집합
    - 수행 시 전달되는 매개변수 등을 유지하는 스택도 필요
      
    ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/1bfb3327-20de-40a8-8947-e495a08b560a)

    - **프로세스 이미지**
        - 사용자 프로그램, 사용자 데이터, 시스템 스택, 프로세스 제어 블록이 포함
        - 메모리의 연속된 인접 블록에 위치할 수 있음. 보통 디스크에서 관리되고, 일부를 주기억장치 내에 유지해 프로세스 관리 가능
        - 프로세스 테이블에는 각 프로세스 이미지에 대한 페이지들의 위치를 유지할 수 있는 필드가 존재해야 함
        ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/6f9fac44-b94c-47f5-b874-b49194670b57)
          - 가상메모리에서의 프로세스 이미지 구조
          - 프로세스 이미지의 주소 범위는 불연속적일 수 있음
  
- **프로세스 제어 블록에 포함되는 프로세스 속성**
    - **프로세스 식별**
        - 운영체제는 각 프로세스에 유일한 식별자 할당
        - 식별자를 사용해 다른 테이블들이 프로세스 테이블 참조 가능
    - **처리기 상태 정보**
        - 처리기 레지스터 내용
        - 처리기에 포함되는 PSW 레지스터에 상태 정보가 저장됨
    - **프로세스 제어 정보**
      +프로세서 제어 블록들을 연결하는데 사용되는 포인터

- **프로세스 제어블록(PCB)의 역할**
    - 운영체제에게 필요한 프로세스의 모든 정보
    - 운영체제 내의 수많은 루틴들은 PCB 내의 정보들에 접근할 수 있어야 함
    - PCB 보호를 위해 운영체제의 모든 루틴이 핸들러 루틴을 거치도록 함

## 3.4 프로세스 제어

### 수행모드

- **사용자 모드** (권한을 덜 가짐)
- **커널 모드, 시스템 모드, 제어 모드** (더 높은 권한을 가짐)

⇒ 사용자 프로그램으로부터 주요 운영체제 테이블을 보호하는 목적

- 처리기 내 PSW의 한 비트를 사용해 수행 모드를 나타냄

### 프로세스 생성

1. 새 프로세스에 유일한 프로세스 식별자 할당. 이 때 프로세스 테이블에 새 항목이 추가됨.
2. 프로세스에 공간을 할당. 이 공간에 프로세스 이미지가 저장됨.
3. 프로세스 제어 블록 초기화. ex) 프로세스 상태 → 준비 or 준비/보류 상태로 초기화
4. 적절한 연결 설정 
5. 다른 자료구조 생성 또는 확장 ex) 과금 등의 목적으로 사용될 어카운팅 파일 

### 프로세스 교환

- **프로세스 교환 시점**
    
    프로세스 수행 중 운영체제로 제어가 넘어가게 하는 사건
    
    1. **인터럽트**
        - **클럭 인터럽트** : 프로세스가 시간 할당량을 다 사용한 경우
        - **입출력 인터럽트**
        - **메모리 폴트** : 처리기가 주기억장치에 없는 워드에 대한 가상메모리 주소를 참조해야 할 때, 메모리 블록을 주기억장치로 가져오기 위한 입출력 요청 발생
    2. **트랩**
        - 오류나 예외 상황 처리
        - 치명적이라면 프로세스는 종료
    3. **수퍼바이저 호출**
    
- **모드 전환**
    - 처리기는 인터럽트 시그널 존재 여부로 인터럽트가 발생되었는지 검사
    - 인터럽트가 없다면 처리기는 반입 단계를 계속 수행
    - 인터럽트가 있다면 다음 작업 수행
        1. PC 값을 인터럽트 핸들러 프로그램 시작 주소로 설정
        2. 사용자 모드 → 커널 모드 전환 (인터럽트 처리 코드는 커널에서만 수행 가능)
    - 수행 상태에 있는 프로세스의 상태를 바꾸지 않아도 된다!
    
- **프로세스 상태 변경**
    1. PC, 다른 레지스터를 포함한 처리기 문맥 저장
    2. 현재 수행 상태인 프로세스의 제어 블록 갱신 후 상태 전이 
    3. 프로세스 제어 블록을 적절한 큐로 옮김 (준비, 블록, 준비/보류 큐)
    4. 다음에 수행할 프로세스 선택
    5. 선택된 프로세스의 제어블록 갱신 → 수행 상태로 전이
    6. 자료구조 갱신
    7. 선택된 프로세스가 마지막으로 수행되었을 때의 처리기 문맥 복원 
    
    ⇒ 모드 전환에 비해 많은 작업 요구됨

## 3.5 운영체제의 수행
### 비프로세스 커널

운영체제를 프로세스로 보지 않는 방법
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/cba3c16f-b8a7-459a-800a-1afc8799c024)

- 모든 프로세스의 외부에서 운영체제 커널 수행
- 인터럽트, 트랩 등 발생 시, 문맥이 저장되고 제어가 커널로 넘어감
- 운영체제는 자신이 사용할 메모리 영역과 시스템 스택을 가짐
- 운영체제 코드는 분리된 개체로서 특권모드에서 동작

### 사용자 프로세스 내에서 수행

보통 작은 컴퓨터 상에서 구동되는 운영체제가 취하는 방식
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/b5adde97-146f-440f-b1d5-7eb670d899a2)

- 사용자 프로세스 문맥에서 모든 운영체제 수행
- 운영체제는 특정 시점에 N개의 프로세스 이미지를 관리
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/5ae64c2a-1923-4a15-9d7f-842083f34aac)

- 각 이미지에는 커널 프로그램을 위한 프로그램, 데이터, 스택 영역이 포함
- 운영체제 코드와 데이터는 공유 주소 공간에 있어 모든 사용자 프로세스가 공유 가능
- 인터럽트, 트랩 등 발생 시, 운영체제 루틴으로 모드 전환이 이루어지지만 수행은 여전히 사용자 프로세스 내에서 계속됨
- 프로세스 내에서 사용자 프로그램, 운영체제 프로그램이 모두 수행될 수 있지만, 다양한 사용자 프로세스 내에서 수행되는 운영체제 프로그램은 동일

### 프로세스 기반 운영체제

운영체제를 시스템 프로세스들의 집합으로 구현 
![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/b2745635-6146-4207-ac0e-f108e8d2f16f)

- 커널의 주요 기능이 여러 개의 분리된 프로세스로 구성
- 운영체제를 모듈화해 프로그램 설계 원칙에 충실할 수 있음
- 운영체제의 중요하지 않은 몇 기능들을 개별 프로세스로 쉽게 구현 가능
- 다중 처리기, 멀티 컴퓨터 환경에서 유용 → 몇 가지 서비스를 지정된 처리기에서 수행
