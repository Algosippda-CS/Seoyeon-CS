# 1장 컴퓨터 시스템의 개요

## 기본 구성 요소

### 컴퓨터의 기본 구성 요소

1. **처리기 (CPU)** : 컴퓨터의 동작 제어, 데이터 처리
2. **주기억장치** : 데이터와 프로그램 저장, 휘발성
3. **입출력 모듈** : 컴퓨터 - 외부 환경(보조 기억장치 포함) 간 데이터 이동 담당 
4. **시스템 버스** : 처리기, 주기억장치, 입출력 모듈 간 통신 제공 
    
    ⇒ CPU의 성능뿐만 아니라 시스템 버스의 성능도 중요
    

### CPU
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/c018dbd8-aa24-4e2b-9074-c888b054605d)

- 시스템 버스를 통해 메모리와 데이터 교환
- CPU 내 레지스터 종류
    - **PC(프로그램 카운터)** : 다음에 가져올 명령어의 주소 보관
    - **IR(명령어 레지스터)** : 반입된 명령어 자체를 보관
    - **MAR(메모리 주소 레지스터)** : 접근할 메모리 주소를 보관
    - **MBR(메모리 버퍼 레지스터)** : 메모리에 저장될, 혹은 잃어온 데이터 보관
    - **I/O AR(입출력 주소 레지스터)**
    - **I/O BR(입출력 버퍼 레지스터)**
    - **AC(누산기)** : 데이터 연산 결과를 일시적으로 저장

### 주기억장치

- 일련번호로 주소가 부여된 공간들의 집합
- 각 공간에 명령어 또는 데이터가 이진수로 저장됨

### 입출력 모듈

- 외부 장치와 CPU, 메모리 간 데이터 전송
- 일시적으로 데이터를 보관할 내부 버퍼를 가짐

## 명령어 수행

- 프로그램 : 메모리에 저장된 명령어들의 집합

### 명령어 싸이클

  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/3d62d593-b886-4dc8-9b60-93330685c117)

- 메모리로부터 하나의 명령어를 읽고 수행
    - 반입 (fetch)
    - 수행 (execution)
    
    ### 전체적인 싸이클
    
    1. PC에 저장된 명령어의 주소를 읽어와야 함 
        - 주소에서 데이터를 빼오고 나면 PC 증가
    2. MAR에 PC에 저장된 주소 임시 보관
    3. 시스템 버스를 통해 주소에 접근해 명령어를 MBR에 임시보관
    4. IR에 명령어 보관
    5. 처리기는 명령어를 해석하고 요구된 작업 수행 
        1. 처리기-메모리 : 데이터 전송
        2. 처리기-입출력 : 주변장치와 처리기 간 데이터 전송
        3. 데이터 처리 : 데이터에 대한 산술 논리 연산
        4. 제어 : 수행 순서 변경을 제어
    
    ### 명령어
    
    - 연산코드(4비트) + 주소(12비트)
    - 명령어와 데이터 모두 16비트
    

## 인터럽트

- 처리기가 일반적인 처리를 진행 중일 때, 다른 모듈들이 인터럽트를 걸어 중단시킬 수 있음
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/f27b69d3-76a6-43e0-8d90-de24b195a9ad)

- 대부분 입출력 장치는 CPU에 비해 훨씬 느리기 때문에, 입출력 장치가 명령을 완료할 때까지 CPU가 무한 대기하는 것은 비효율적
    
    ⇒ 입출력 연산 진행하는 동안 CPU는 다른 명령어를 수행할 수 있음
    

### 인터럽트와 명령어 사이클

1. CPU는 프로그램 수행 중
2. 수행 중 입출력 프로그램 호출
3. 입출력 명령어 수행된 후 제어는 기존 프로그램으로 리턴
4. 외부 장치에서 ex. 인쇄 수행과 기존 프로그램 명령어 수행 동시에 진행
5. 외부 장치가 다시 서비스할 준비가 됐을 때, 외부장치의 입출력 모듈에서 인터럽트 요청 신호를 cpu로 전송
6. 수행 중이던 기존 프로그램 작업 보류
7. 인터럽트 처리기 프로그램으로 제어 넘김 
8. 외부 장치에 대한 서비스 후에 다시 보류한 프로그램 수행 재개

⇒ 프로그램은 인터럽트 처리에 대해 고려할 필요 없다! (특별 코드가 필요 없음)

**⇒ 인터럽트에 의해 프로그램 수행을 보류, 재개하는 것은 CPU, OS의 몫**

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/f6099b0a-de54-40ee-8784-aede67809e6c)

- CPU는 인터럽트 발생 여부를 검사
    - 인터럽트가 발생하지 않은 경우 : 수행 중인 프로그램의 다음 명령어를 반입
    - 인터럽트 발생한 경우 : 프로그램 실행을 멈추고, 인터럽트 처리 루틴 실행

### 인터럽트 처리

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/e8377cb2-a2bf-40fb-9973-679efb21715d)

- 처리기가 PSW와 PC를 제어 스택에 저장함
    - PSW (프로그램 상태 워드) : 수행이 멈춘 그 시점에서 다음 명령어의 위치, 메모리 사용 정보, 커널/사용자 모드 비트 등의 내용
    - 엄밀히 말하면 PSW 안에 PC 값도 포함됨
        
        ⇒ 프로그램 수행 재개를 위해 필요한 정보 
        
- 인터럽트 처리기에서 기존 프로그램의 레지스터 값들이 사용될 수 있으므로, 인터럽트 처리기는 모든 레지스터의 내용을 스택에 저장함
- 인터럽트 처리 완료 후, 저장된 레지스터 값을 검색해 레지스터에 다시 저장(상태 정보 복구)
- 제어 스택으로부터 PSW와 PC 값을 복구

### 중첩 인터럽트

- 하나의 인터럽트를 처리하는 와중에 또 다른 인터럽트가 발생하는 경우
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/1b04be69-ee9c-4aea-9454-0ba1122b6927)

1. **하나의 인터럽트를 처리하는 동안 다른 인터럽트 금지시키기** 
    - CPU가 인터럽트 요구 신호를 무시한다.
    - 인터럽트 처리 후 원래 수행중이던 프로그램이 재개되기 전, 나머지 인터럽트가 허용된다.
    - **인터럽트가 순차적으로 처리**
2. **인터럽트 간 우선순위 정의 후, 순위대로 처리** 
    - 낮은 순위 인터럽트 수행 중에 높은 우선순위 인터럽트에게 제어를 뺏길 수 있다.
    - **인터럽트 중첩 처리**

## 메모리 계층 구조

- 메모리 관련 3가지 주요 특성 ⇒ **용량, 접근 속도, 비용**
    - 접근 시간 짧을수록 비트당 비용 높아짐
    - 용량 클수록 비트당 비용 낮아짐
    - 용량 클수록 접근 시간 길어짐
    
- 설계자는 용량, 비용 면에서 대용량 메모리를 제공해야 하는 한편, 성능을 위해 저용량 메모리도 사용해야 함
    
    ⇒ 따라서 단일 메모리를 사용하지 않고 **메모리 계층 구조**를 채택!
  
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/100ef128-c069-40b3-ad18-fdb5148ffa03)

  - 계층 아래쪽으로 갈 수록
      - 비트당 비용 감소
      - 용량 증가
      - 접근 시간 증가
      - CPU에 의한 메모리 접근 회수 감소
  
  ⇒ 느린 메모리에 대한 접근 회수를 줄임으로써 성능 향상 

- **참조지역성**에 의해 하위 단계에 대한 접근 비율이 낮아지도록 데이터 구성 가능
    - **참조 지역성**
        - 프로그램 수행 시 처리기가 참조하는 메모리는 인근 지역으로 몰리는 경향이 있음
        - 단기적으로 처리기는 고정된 메모리 참조 집단을 주로 이용
    
    ⇒ 필요한 데이터의 묶음이 더 높은 단계의 메모리로 올라와 있는 경우 多
    

## 캐시 메모리

- 모든 명령어 싸이클에서 CPU는 명령어를 가져오기 위해 최소 한 번 메모리에 접근
- 메모리와 CPU 간 속도 차이가 커서 명령어 수행 속도에 제약이 생김
    
    ⇒ CPU와 메모리 사이에 용량 적고, 빠른 캐시 메모리를 제공!!
    

### 캐시의 원리

- 캐시는 주메모리 일부의 복사본을 포함한다.
- CPU가 메모리에서 데이터를 읽으려 할 때, 그 데이터가 캐시에 있는지 우선 점검
    - 캐시에 있다면, CPU로 데이터 바로 전달
    - 캐시에 없다면, 주메모리 블록 일부가 캐시로 올라온 뒤 해당 데이터 전달
    - 참조지역성에 의해 그 이후에 참조되는 데이터는 캐시에 올라온 블록 내에 있을 확률이 높다.

### 다단계 캐시
  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/8fd9b562-7f2f-4099-8abc-fa313ffa5b6b)
- 여러 캐시를 계층적 구조로 사용해 캐시에 데이터가 없는 실패 손실을 줄이는 기술

### 캐시/주기억장치 구조

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/c7c9b2b2-535f-464c-a5af-c420f2e4dae6)

- **주기억장치**
    - K개의 워드로 된 고정 길이 블록들 여러 개로 구성

- **캐시**
    - K개의 워드로 된 C개의 슬롯으로 구성
    - 즉 하나의 슬롯에 하나의 블록이 할당됨
    - 캐시에 없는 블록 내의 워드를 읽어야 하면, 주기억장치의 해당 블록이 슬롯 중 하나로 전달됨

### 캐시 설계

- **캐시 크기**
- **블록 크기**
    - 블록 크기가 커지면, 적중률(캐시 내에 원하는 워드가 있을 가능성) 높아짐
    - 그러나 너무 커지면 오히려 적중률 낮아짐
- **사상 함수**
    - 블록이 캐시의 어느 위치에 저장될지 결정함
- **교체 알고리즘**
    - 모든 슬롯이 채워져 있는 경우, 새로운 블록을 들여올 때 어떤 슬롯을 비워야 할지 ⇒ 가장 오래 참조되지 않은 블록을 교체하는 **LRU 알고리즘**이 효과적
- **쓰기 정책**
    - 캐시 내의 어떤 블록 내용이 변경되었을 때, 교체 전에 주기억장치의 블록도 동일하게 갱신해줘야 함
    - 쓰기 정책이 이 연산을 언제 수행할지 결정함
    - ex) 블록이 갱신될 때마다, 블록이 교체될때만
- **캐시 단계 수**

## 직접 메모리 접근

### I/O연산을 위해 사용 가능한 기법

1. **프로그램된 입출력**
    - 입출력 모듈이 요청된 행위를 수행한 후, 입출력 상태 레지스터 내 관련 비트만 설정
    - CPU가 주체적으로 입출력 연산이 완료 여부를 알기 위해 입출력 모듈의 상태를 주기적으로 점검해야 함
        
        **⇒ 성능 다운**
        
2. **인터럽트 구동 입출력**
    - 입출력 모듈에게 명령 보낸 후 CPU는 다른 작업 수행
    - 입출력 모듈이 할 일을 마치면 CPU 인터럽트
        
        ⇒ 메모리-입출력 모듈 간 데이터 전송에 CPU가 적극 개입
        

⇒ 입출력 전송률은 프로세서가 장치를 점검하고 서비스하는 속도에 제한 받음

⇒ 프로세서가 입출력 전송을 할 때마다 많은 명령어가 수행됨

1. **직접 메모리 접근 (DMA)**
    - 대량의 데이터 이동 시 효율적인 기술
    - DMA는 시스템 버스 상 별도 모듈에 의해 수행 OR 입출력 모듈에 포함 가능
    - CPU가 한 블록의 데이터에 접근할 때 DMA 모듈에 다음 정보를 보내 입출력 명령
        - 읽기 요청인지 쓰기 요청인지
        - 관련 입출력 장치 주소
        - 접근할 메모리 내 시작 위치
        - 접근할 워드 개수
    - 명령 후 CPU는 다른 작업 진행 ⇒ 입출력 연산을 DMA 모듈에 위임

## 멀티 프로세서와 멀티코어 구조

### 대칭형 멀티 프로세서 (SMP)

1. 둘 이상의 비슷한 수행 능력을 갖는 프로세서로 구성
2. 프로세서는 주기억장치, 입출력 장치를 공유해, 각 프로세서가 접근하는 시간은 거의 동일
3. 모든 프로세서는 입출력 장치 접근 공유
4. 모든 처리기는 동일한 기능 수행 가능
5. 시스템은 하나의 통합된 운영체제에 의해 제어

- **SMP의 장점**
    - **성능** : 작업의 일부가 병렬로 처리 가능해져 성능이 향상됨
    - **가용성** : 하나의 처리기가 고장나도 지속적인 동작 가능
    - **점진적 확장** : 성능 향상을 위해 처리기 추가 설치 가능
    - **크기 조정** : 처리기 수에 따라 가격과 성능이 다른 다양한 제품 공급 가능
    
- 여러 CPU의 존재가 사용자에게 투명함
- OS는 각 CPU에 대한 스케줄링을 담당하고, CPU 간 동기화를 책임짐

  ![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/9523cd87-d44f-40ac-b75e-8072c8617c7f)
  - 프로세서는 메모리 에 저장되어 있는 상태 정보를 통해 서로 통신 가능
  - 일반적으로 각 프로세서는 한 단계 이상의 캐시 메모리 포함
      ⇒ 각 프로세서 간 캐시 일관성 문제 
    

### 멀티코어 컴퓨터 (칩 멀티프로세서)

- 하나의 칩에 2개 이상의 프로세서를 결합한 형태
- 각 코어는 독립적인 프로세서의 모든 구성요소를 포함 + 캐시
- 컴퓨터 구성요소를 소형화해 프로세서를 캐시에 가깝게 위치

![image](https://github.com/Algosippda-CS/Seoyeon-CS/assets/42333313/7e63d39a-365d-4c88-8df6-152d1d066cff)
